// fireFly POV - Written by Buck McGibbony, copyright 2014-2020 - all rights reserved.
//
//

#include <dummy.h>
#include <FastLED.h>

#include <ESP8266WiFi.h>
#include <ArduinoJson.h>
#include <EEPROM.h>
#include <ESPAsyncTCP.h>
#include <ESPAsyncWebServer.h>
//#include <ESP8266WebServer.h>
//#include <ESP8266mDNS.h>
#include <DNSServer.h>
#include <WebSocketsServer.h>

#define VERSION "2.2.0"

#define DATA_PIN		1
#define CLOCK_PIN		3
#define LED_BUILTIN		2
#define WIFI_TIMEOUT	7	// seconds
#define PHY_MODE		WIFI_PHY_MODE_11G

const char* hostName = "lightbrush";
const byte DNS_PORT = 53;
DNSServer dnsServer;

AsyncWebServer  server(80);
//ESP8266WebServer	server(80);
WebSocketsServer webSocket(791);		// create a websocket server on port 781

// attach font generated by POV Font Muncher
#include "Lucida_Console.h"
#define CharacterMap Lucida_Console
#define g_nASCIIStart Lucida_Console_nASCIIStart
#define g_nASCIIEnd Lucida_Console_nASCIIEnd

// serial communication settings
#define USB_BAUD_RATE 115200

#define PWM_TIMEOUT 25000UL
#define PWM_NOISEFLOOR 10

#define COOLING_MAX 190
#define COOLING_MIN 65

#define SPARKING_MIN 25
#define SPARKING_MAX 35

#define SPARKING_THRESH .9f

int COOLING = COOLING_MAX;
int SPARKING = SPARKING_MIN;

// Globals

// Bitmaps
//#include "DR1_Racing_Logo_sz64.h" // DRL Logo
//_pixelrgb *oBitmapBuffer;

// PWM Sample rate in cycles per second
const int g_nSampleRate = 15;

unsigned long g_nLastPWMOrientationValue = 0;

// render states
unsigned int g_nFrameRate = 0;		// frame rate
byte g_nOrientation = 0;			// letter orientation

uint8_t g_nCurrentMessage = 0;		// message number
int g_nCharNum = 0;					// character number, used as an index into sMessage[]
byte g_nCurrentChar = 0;			// normalized current char ascii, converted to an index into the font* table
const uint32_t *g_nColumnPtr;		// address to the current char and columns 32 bit DWORD of bits
uint8_t g_nCharWidth;				// char width in pixels
int g_nColumnNum;					// column number of char
int g_nAnimSpeed = 1;				// animation speed
int g_nAnimFrames = 256;			// number of frames to animate through

byte g_nBackBright;
CRGB g_cFontRender;

int g_nEffectID = 0;				// Background ID number ( -x=Graphic n, 0=Black, 1=Navigation, 2=Rainbow, 3=Thruster)
int g_nEffectPalleteID = 0;

char g_sStatusMsg[64];

// number of RGB LEDs in strand
const uint16_t g_nFontPixels = 32;

// composition buffer
CRGB *g_cPixels = 0;
uint16_t *heat = 0;
uint16_t *nBitmapScalarMap = 0;

enum STRIP_TYPE {
	aWS2812B = 1,
	aLPD8806 = 2,
};

// Settings functions
//
// increment this every time you make ANY change to the Settings or Calibrations structure
// this way we can know when to revert to defaults after a code update
byte SettingsVersion = 3;
struct Settings_t {
	//strip
	STRIP_TYPE nStripType;		// type of LED strip
	uint8_t nPixelsMulti;		// Multiply pixels - each internal pixel fills nPixelsMulti LED pixels on the strip for better long distance viewing and brightness
	uint16_t nNumPixels;		// Number of pixels in the LED strip
	uint8_t nNumSegments;		// Number of segments for this strip
	char sSegmentSetup[25];		// Message format string array (1n2f = segment 1 normal, segment 2 flipped

	// frame rates
	uint16_t nMinFrameRate;		// min frame rate
	uint16_t nMaxFrameRate;		// max frame rate

	// font settings
	byte nInterCharFrameGap;	// this is the number of frames between each char 
	byte nBackBrightness;		// 0-9
	byte nFontBrightness;		// 0-9

	// PWM input settings
	int8_t nFrameRatePin;		// pin for frame rate control, set to 0 for no frame rate control, default frame rate will then be nMaxFrameRate
	int8_t nMessageSelectPin;	// Pin for pattern select control, 0 - -15 for analog inputs along A0-A15
	int8_t nOrientationPin;		// pin for orientation (left to right/right to left {upside down}) control, 0 for no orientation control
	byte nOrientationDeadZone;	// dead zone for orientation flip control, in percent of full range of control
	byte nOrientationInverts;	// invert orientation in relation to control
	uint8_t nFullTimeNav;		// full time nav on tips

	// Messages and formatting
	byte nNumMessages;			// Number of active messages
	byte nDefaultMessage;		// default message num on start up
	char sMessage[9][33];		// Message string array
	char sFormat[9][13];		// Message format string array
};
Settings_t Settings;

struct Calibrations_t {
	unsigned int nFrameRate_LowVal;  //default is 1000 (microseconds)
	unsigned int nFrameRate_HighVal;  // default is 2000 (microseconds)
	unsigned int nMessageSelect_LowVal;  //default is 1000 (microseconds)
	unsigned int nMessageSelect_HighVal;  // default is 2000 (microseconds)
	unsigned int nOrientation_LowVal;  //default is 1000 (microseconds)
	unsigned int nOrientation_HighVal;  // default is 2000 (microseconds)
	unsigned int nOrientation_Normal;  // default is 50 (mapped 0-101)
};
Calibrations_t Calibrations;

// LoadDefaults
//
void LoadDefaults() {
	//Serial.println("LoadDefaults()");

	Settings.nStripType = aWS2812B;
	Settings.nNumPixels = 144;
	Settings.nNumSegments = 1;
	strcpy(Settings.sSegmentSetup, "1n");

	Settings.nPixelsMulti = 1;

	Settings.nFontBrightness = 8;	// 0-10
	Settings.nBackBrightness = 5;	// 0-10
	Settings.nMinFrameRate = 90;
	Settings.nMaxFrameRate = 140;

	Settings.nInterCharFrameGap = 6;

	Settings.nFrameRatePin = 0;
	Settings.nMessageSelectPin = 0;
	Settings.nOrientationPin = 0;

	Settings.nOrientationDeadZone = 5;
	Settings.nOrientationInverts = 1;
	Settings.nFullTimeNav = true;

	Settings.nNumMessages = 9;
	Settings.nDefaultMessage = 0;
	strcpy(Settings.sMessage[0], "");
	strcpy(Settings.sMessage[1], "");
	strcpy(Settings.sMessage[2], "");
	strcpy(Settings.sMessage[3], "");
	strcpy(Settings.sMessage[4], "");
	strcpy(Settings.sMessage[5], "");
	strcpy(Settings.sMessage[6], "");
	strcpy(Settings.sMessage[7], "fireFLY LightBrush   ");
	strcpy(Settings.sMessage[8], "");

	strcpy(Settings.sFormat[0], "/e3/p1");
	strcpy(Settings.sFormat[1], "/e3/p2");
	strcpy(Settings.sFormat[2], "/e3/p3");
	strcpy(Settings.sFormat[3], "/e3/p4");
	strcpy(Settings.sFormat[4], "/e3/p5");
	strcpy(Settings.sFormat[5], "/e2");
	strcpy(Settings.sFormat[6], "/e2");
	strcpy(Settings.sFormat[7], "/e2/n6");
	strcpy(Settings.sFormat[8], "/e1");

	// global pre-calc vars
	SetBackBrightness(Settings.nBackBrightness);
	SetFontBrightness(Settings.nFontBrightness);

	Calibrations.nFrameRate_LowVal = 1000;
	Calibrations.nFrameRate_HighVal = 2000;
	Calibrations.nMessageSelect_LowVal = 1000;
	Calibrations.nMessageSelect_HighVal = 2000;
	Calibrations.nOrientation_LowVal = 1000;
	Calibrations.nOrientation_HighVal = 2000;
	Calibrations.nOrientation_Normal = 50;

	//save to EEPROM
	SaveSettings();
	SaveCalibrations();
}


// LoadSettings
//
void LoadSettings() {
	byte nCurrentSettingsVersion;

	//Serial.println("LoadSettings()");

	EEPROM.begin(sizeof(SettingsVersion) + sizeof(Settings));

	EEPROM.get(0, nCurrentSettingsVersion);
	if (nCurrentSettingsVersion == SettingsVersion) {
		// load settings
		EEPROM.get(sizeof(SettingsVersion), Settings);

		// load calibrations
		EEPROM.get(sizeof(SettingsVersion) + sizeof(Settings), Calibrations);
		EEPROM.end();
	}
	else {
		EEPROM.end();
		Serial.println("EEPROM settings version mismatch, loading defaults.");
		LoadDefaults();
	}

	// global pre-calc vars
	SetBackBrightness(Settings.nBackBrightness);
	SetFontBrightness(Settings.nFontBrightness);
	g_nCurrentMessage = Settings.nDefaultMessage;
}

// SaveSettings
//
void SaveSettings() {
	//Serial.println("SaveSettings()");

	EEPROM.begin(sizeof(SettingsVersion) + sizeof(Settings));

	// save settings version
	EEPROM.put(0, SettingsVersion);

	// save settings
	EEPROM.put(sizeof(SettingsVersion), Settings);

	EEPROM.end();
}

// SaveCalibrations
//
void SaveCalibrations() {
	EEPROM.begin(sizeof(SettingsVersion) + sizeof(Settings) + sizeof(Calibrations));

	// save PWM calibration values
	EEPROM.put(sizeof(SettingsVersion) + sizeof(Settings) , Calibrations);

	EEPROM.end();
}


// InitStrip
//
void InitStrip() {

	// allocate composition buffer
	if (g_cPixels) {
		delete[] g_cPixels;
		delete[] heat;
		delete[] nBitmapScalarMap;
		//delete[] oBitmapBuffer;
	}

	g_cPixels = new CRGB[Settings.nNumPixels];
	heat = new uint16_t[Settings.nNumPixels/Settings.nNumSegments];
	nBitmapScalarMap = new uint16_t[Settings.nNumPixels];

	//oBitmapBuffer = (_pixelrgb*)malloc(sizeof(oBitmap));
	//oBitmapBuffer = new _pixelrgb[sizeof(oBitmap)];
	//memcpy(oBitmapBuffer, oBitmap, sizeof(oBitmap));

	// init FastLED
	switch (Settings.nStripType) {
	case aWS2812B:
		FastLED.addLeds<WS2812B, DATA_PIN, GRB>(g_cPixels, Settings.nNumPixels).setCorrection(TypicalLEDStrip);
		break;

	case aLPD8806:
		FastLED.addLeds<LPD8806, DATA_PIN, CLOCK_PIN, RGB>(g_cPixels, Settings.nNumPixels).setCorrection(TypicalLEDStrip);
		break;
	}
	
	FastLED.setBrightness(255);
}


// SetPixel()
//	
inline void SetPixel(int n, CRGB c) {
	for (unsigned int i = 0; i < Settings.nPixelsMulti; i++) {
		g_cPixels[n * Settings.nPixelsMulti + i] = c;
	}
}

inline void SetFontBrightness(int nBrightness) {
	g_cFontRender.r = (uint8_t)map(nBrightness, 0, 10, 0, 255);
	g_cFontRender.g = g_cFontRender.r;
	g_cFontRender.b = g_cFontRender.r;
}
inline void SetBackBrightness(int nBrightness) {
	g_nBackBright = (uint8_t)map(nBrightness, 0, 10, 0, 255);
}


// ShowStrip()
//
inline void ShowStrip() {
	FastLED.show(); // display this frame
}

// RenderFrame
//
void RenderFrame() {

	static int nFrameDelay = 0;			// Skip n frames, this creates inter charactor spacing
	static int nFrameAnimator = 0;		// This just loops from 0-359 - used for animation

	bool bInhibit = false;
	uint32_t buffer = 0;
	uint16_t i = 0;
	uint16_t iprime = 0;

/*	if (bInhibit) {
		if (analogRead(2) > 50) {
			bInhibit = false;
		}
		else {
			// clear the strip
			FastLED.clear();
			return;
		}
	}
*/

	// render background
	switch (g_nEffectID) {
	case -1:
		FastLED.setBrightness(g_nBackBright);
		//Effect_Graphic(abs(g_nEffectID), nFrameAnimator);
		break;

	case 3:
		// call this effect once to render a full frame of effect
		Effect_PlasmaThrust(g_nBackBright);
		break;

	default:
		for (i = 0; i < g_nFontPixels; i++) {
			//iprime = (g_nOrientation ^ ((Settings.nOrientationInverts & 2) >> 1)) ? g_nFontPixels - i - 1 : i;
			iprime = ((Settings.nOrientationInverts & 2) >> 1) ? g_nFontPixels - i - 1 : i;
			switch (g_nEffectID) {
			case 0:
				SetPixel(i, CRGB::Black);
				break;
			case 1:
				SetPixel(i, Effect_Navigation(iprime, 255));
				break;
			case 2:
				SetPixel(i, Effect_Rainbow(iprime, nFrameAnimator, g_nBackBright));
				break;
			default:
				break;
			}
		}
	}

	// full time nav
	if( Settings.nFullTimeNav) {
		for (i = 0; i < g_nFontPixels; i++) {
			if ((i < 3 || i >= g_nFontPixels - 3)) {
				//iprime = (g_nOrientation ^ ((Settings.nOrientationInverts & 2) >> 1)) ? g_nFontPixels - i - 1 : i;
				iprime = ((Settings.nOrientationInverts & 2) >> 1) ? g_nFontPixels - i - 1 : i;
				SetPixel(i, Effect_Navigation(iprime, 255));
			}
		}
	}

	// increment animator
	nFrameAnimator = (nFrameAnimator + g_nAnimSpeed) % g_nAnimFrames;

	// in frame delay?
	if( nFrameDelay < 1) {
		// regular frame
		// read font data from program memory
		//buffer = pgm_read_dword(g_nColumnPtr);
		buffer = pgm_read_dword(g_nColumnPtr + g_nColumnNum);

		// copy column bits to strip
		for (i = 0; i < g_nFontPixels; i++) {
			// read a bit, if we are flipped then read in opposite order, respecting Settings.nOrientationInverts bit 2 toggle (x value from settings)
			iprime = (g_nOrientation ^ ((Settings.nOrientationInverts & 2) >> 1)) ? g_nFontPixels - i - 1 : i;
			if (bitRead(buffer, iprime)) {
				// there is font color here set to that
				SetPixel(i, g_cFontRender);
			}
		}

		// move to next column/charactor based on current orientation (0-normal, 1-flipped)
		if (g_nOrientation ^ (Settings.nOrientationInverts & 1)) {
			// flipped orientation

			// advance to previous column
			g_nColumnNum--;

			// are we past the beginning of the current char?
			if (g_nColumnNum <= 0) {

				// go to previous character in sMessage
				g_nCharNum--;
				nFrameDelay = Settings.nInterCharFrameGap;

				// past beginning of string?
				if (g_nCharNum < 0) {
					// wrap back to beginning
					g_nCharNum = strlen(Settings.sMessage[g_nCurrentMessage]) - 1;

					// this is for the wand, put a button to ground on A2 for inhibit switch
					// if A2 < 50 (noise level) - inhibit render
					//if (analogRead(2) < 50) {
					//	bInhibit = true;
					//}
				}

				// set index and pointer for next call to RenderFrame
				g_nCurrentChar = constrain(Settings.sMessage[g_nCurrentMessage][g_nCharNum] - g_nASCIIStart, 0, g_nASCIIEnd - g_nASCIIStart);
				g_nColumnPtr = CharacterMap[g_nCurrentChar];
				g_nCharWidth = (uint8_t)pgm_read_dword(g_nColumnPtr);
				// set to end of current char
				g_nColumnNum = g_nCharWidth;
			}
		}
		else {
			// normal orientation

			// advance to next column
			g_nColumnNum++;

			// are we at the end of the current char?
			if (g_nColumnNum > g_nCharWidth) {

				// go to next character in sMessage
				g_nCharNum++;
				nFrameDelay = Settings.nInterCharFrameGap;

				// end of string?
				if ((unsigned int)g_nCharNum >= sizeof(Settings.sMessage[g_nCurrentMessage]) - 1 || Settings.sMessage[g_nCurrentMessage][g_nCharNum] == '\0') {
					// wrap back to beginning
					g_nCharNum = 0;

					// this is for the wand, put a button to ground on A2 for inhibit switch
					// if A2 < 50 (noise level) - inhibit render
					//if (analogRead(2) < 50) {
					//	bInhibit = true;
					//}

				}

				// set index and pointer for next call to RenderFrame
				g_nCurrentChar = constrain(Settings.sMessage[g_nCurrentMessage][g_nCharNum] - g_nASCIIStart, 0, g_nASCIIEnd - g_nASCIIStart);
				g_nColumnPtr = CharacterMap[g_nCurrentChar];
				g_nCharWidth = (uint8_t)pgm_read_dword(g_nColumnPtr);
				// set to beginning of current char
				g_nColumnNum = 1; // 0 is the char width
			}
		}
	}
	else {
		nFrameDelay--;
	} // frame delay else

}

/*
//	Effect_Graphic
//
//
void Effect_Graphic(int nGraphicID, int nImageColumn) {
	
	if( nImageColumn < oBitmap_width) {

		uint16_t jprime = 0;
		uint8_t nSegment = 0;
		uint16_t nIndex = nImageColumn * oBitmap_height;
		uint16_t nIndexMirror = ( oBitmap_width - nImageColumn) * oBitmap_height;

		for (uint16_t j = 0; j < Settings.nNumPixels; j++) {
			nSegment = int(Settings.nNumPixels / Settings.nNumSegments / j);
			jprime = (nSegment % 2 ? nIndexMirror : nIndex) + nBitmapScalarMap[j];
			//memcpy( &g_cPixels[j], &oBitmap[nIndex + nBitmapScalarMap[j]], 3);
			g_cPixels[j].r = oBitmapBuffer[jprime].r;
			g_cPixels[j].g = oBitmapBuffer[jprime].g;
			g_cPixels[j].b = oBitmapBuffer[jprime].b;
		}
	}
	else {
		FastLED.clear();
	}
}
*/

//	Effect_Rainbow
//
//		int i				- pixel num
//		int nDegrees,		- 0 - 255 - call with incrementing number to animate
//		int coef			- brightness
//
inline CRGB Effect_Rainbow(int i, int nDegrees, int bright) {
	return ColorFromPalette(RainbowColors_p, i * (256 / g_nFontPixels) + nDegrees, bright);
}


//	Effect_Navigation
//
//		int i				- pixel num
//		int bright			- brightness
//
inline CRGB Effect_Navigation(int i, uint8_t bright) {
	return (i < (g_nFontPixels / 2)) ? (CRGB) { bright, 0, 0 } : (CRGB) { 0, bright, 0 };
	//return (i < (g_nFontPixels / 2)) ? CRGB::Red : CRGB::Green;
}


//	Effect_PlasmaThrust
//
//
void Effect_PlasmaThrust(int bright)
{
	// Array of temperature readings at each simulation cell
	int nEffectWidth = Settings.nNumPixels / Settings.nNumSegments;
	int nCoolingPrime = (COOLING * 10) / nEffectWidth;
	CRGBPalette16 cPallette;

	switch (g_nEffectPalleteID) {
	case 1: cPallette = HeatColors_p; break;
	case 2: cPallette = CRGBPalette16(CRGB::Black, CRGB::Green, CRGB::Blue, CRGB::Red); break;
	case 3: cPallette = CRGBPalette16(CRGB::Black, CRGB::Red, CRGB::Green, CRGB::Blue); break; // miako
	default:
	case 4: cPallette = CRGBPalette16(CRGB::Black, CRGB::Gold, CRGB::Red, CRGB::DarkBlue); break;  // paul
	case 5: cPallette = CRGBPalette16(CRGB::Black, CRGB::YellowGreen, CRGB::Blue, CRGB::Blue); break;  // miako
	case 6: cPallette = CRGBPalette16(CRGB::Black, CRGB::Blue, CRGB::Aqua, CRGB::Orange); break;
	}

	// Cool down every cell a little
	for (int i = 0; i < nEffectWidth; i++) {
		heat[i] = qsub8(heat[i], random8(nCoolingPrime) + 2);
		//heat[i] = qsub8(heat[i], random8( COOLING) + 2);
	}

	// Constant heat source at center
	//heat[0] = qadd8(heat[0], random8(32));
	//heat[1] = qadd8(heat[1], random8(32));

	// Heat from each cell drifts 'up' and diffuses a little
	for (int k = nEffectWidth - 1; k >= 2; k--) {
		heat[k] = (heat[k - 1] + heat[k - 2] + heat[k - 2]) / 3;
	}

	// Randomly ignite new 'sparks' of heat near the bottom
	if (random8() < SPARKING) {

		// doing this so it has a assymetrical effect across the two sides
		for (int j = random8(2); j <= 3; j += 2) {
			heat[j] = qadd8(heat[j], random8(128, 255));
			heat[j + 1] = qadd8(heat[j + 1], random8(128, 255));
		}
	}

	// Render heat cells with pallette colors
	//SetPixel(nPixel, ColorFromPalette(HeatColors_p, heat[nPixel]));
	for (int nSegment = 0; nSegment < Settings.nNumSegments; nSegment++) {
		for (int j = 0; j < nEffectWidth / 2; j++) {
			g_cPixels[(nSegment*nEffectWidth) + nEffectWidth / 2 + j] = ColorFromPalette(cPallette, scale8(heat[j * 2], 240), g_nBackBright);
			g_cPixels[(nSegment*nEffectWidth) + nEffectWidth / 2 - j - 1] = ColorFromPalette(cPallette, scale8(heat[(j * 2) + 1], 240), g_nBackBright);

			//leds[NUM_LEDS / 2 + j] = HeatColor(heat[j*2]);
			//leds[NUM_LEDS / 2 - j - 1] = HeatColor(heat[(j*2)+1]);
		}
	}

	/*
	if (g_nFrameRate > (unsigned int)((float)Settings.nMaxFrameRate * SPARKING_THRESH)) {
	// Glitter sparkles
	for (int j = 0; j < nEffectWidth; j++) {
	if (random8() < 7 &&				// Master attenuator
	random8() < SPARKING) 			// SPARKING attenuator
	//g_cPixels[j] = ColorFromPalette(cPallette, 255, g_nBackBright);
	g_cPixels[j] = CRGB::White;
	}
	}
	*/
}


// setup()
//
void setup() {

	// open serial ports
	Serial.begin(USB_BAUD_RATE);
	delay(1000);

	//setup GPIO
	pinMode(LED_BUILTIN, OUTPUT);

	// start SPIFFS
	startSPIFFS();

	// load settings
	LoadSettings();

	digitalWrite(LED_BUILTIN, LOW);

	// Start Wifi and web services
	Serial.setDebugOutput(true);
	if (StartWiFi_Client()) {

		// Start website
		StartWebSite();

		// Start WebSocket server
		startWebSocket();
	}
	else {
		Serial.println("WiFi did not connect, no web services.");
		delay(5000);
	}

	digitalWrite(LED_BUILTIN, HIGH);

	// setup pins
	Settings.nFrameRatePin = 0;
	Serial.printf("Settings.nFrameRatePin=%d  Settings.nMessageSelectPin=%d  Settings.nOrientationPin=%d\r\n", Settings.nFrameRatePin, Settings.nMessageSelectPin, Settings.nOrientationPin);
	if (Settings.nFrameRatePin > 0) pinMode(Settings.nFrameRatePin, INPUT);
	if (Settings.nMessageSelectPin > 0) pinMode(Settings.nMessageSelectPin, INPUT);
	if (Settings.nOrientationPin > 0) pinMode(Settings.nOrientationPin, INPUT);

	// start up the LED strip.
	InitStrip();

	// setup first frame
	ResetMessage();

	// set initial PWM values - call 3 times since we multiplex the inputs to keep the speed up
	UpdateInputs(); UpdateInputs(); UpdateInputs();

	//show masthead and prompt
	//Serial.println();
	Serial.print("Welcome to FireFLY LightBrush - By Buck McGibbony and Paul Drucker - Version "); Serial.println(VERSION);
	//Serial.println();
	//Serial.print("fireFly POV>");
}


// loop
//
void loop() {

	static unsigned long g_ulNextFrameTime = 0;
	static unsigned long g_ulNextSampleTime = 0;

	// FrameRate heartbeat
	if (millis() >= g_ulNextFrameTime) {
		g_ulNextFrameTime = millis() + (1000 / g_nFrameRate);
		RenderFrame();
		ShowStrip();
	}

	// PWMSampleRate heartbeat
	if (millis() >= g_ulNextSampleTime) {
		g_ulNextSampleTime = millis() + (1000 / g_nSampleRate);
		UpdateInputs();

		sprintf(g_sStatusMsg, "Frame Rate: %d - Direction: %s",
			FastLED.getFPS(),
			(g_nOrientation ^ ((Settings.nOrientationInverts & 2) >> 1)) ? "Up" : "Down");
	}

	// check for websocket events
	webSocket.loop();
	dnsServer.processNextRequest();

	//service comm port
	while (Serial.available()) SerialEvent();
}

// Start WebSocket server
void startWebSocket() {
	// start the websocket server
	webSocket.begin();
	webSocket.onEvent(webSocketEvent);
	Serial.println("WebSocket server started.");
}

// When a WebSocket message is received
void webSocketEvent(uint8_t num, WStype_t type, uint8_t * payload, size_t length) {

	String sOutputBuffer;
	DynamicJsonBuffer jsonBuffer;
	String sID;
	String sVal;

	digitalWrite(LED_BUILTIN, LOW);

	switch (type) {
		// if the websocket is disconnected
	case WStype_DISCONNECTED:
		Serial.printf("WStype_DISCONNECTED num %u\r\n", num);
		break;

		// if a new websocket connection is established
	case WStype_CONNECTED: {
		IPAddress ip = webSocket.remoteIP(num);
		Serial.printf("WStype_CONNECTED num %u from %d.%d.%d.%d\r\n", num, ip[0], ip[1], ip[2], ip[3]);
		break;
	}

    // if new text data is received
	case WStype_TEXT:
		//Serial.printf("WStype_TEXT from %u: %s\r\n", num, payload);

		JsonObject& root = jsonBuffer.parseObject(payload);

		// capture json data
		sID = root["ID"].asString();
		sVal = root["Value"].asString();
		
		//Serial.printf("[%s]:[%s]\r\n", sID.c_str(), sVal.c_str());

		// ID scan 
		// set ID var to passed value
		if (sID == String("MessageSelect")) {
			g_nCurrentMessage = sVal.toInt() - 1;
			ResetMessage();
			//Serial.println(sID + ":" + String(g_nCurrentMessage));

			sOutputBuffer = "{\"ID\":\"M_1\",\"Value\":\"" + String(Settings.sMessage[g_nCurrentMessage]) + "\"}";
			webSocket.sendTXT(num, sOutputBuffer);

			sOutputBuffer = "{\"ID\":\"A_1\",\"Value\":\"" + String(Settings.sFormat[g_nCurrentMessage]) + "\"}";
			webSocket.sendTXT(num, sOutputBuffer);
		}
		else if (sID == String("M_1")) {
			strcpy(Settings.sMessage[g_nCurrentMessage], sVal.c_str());
		}
		else if (sID == String("A_1")) {
			strcpy(Settings.sFormat[g_nCurrentMessage], sVal.c_str());
		}
		else if (sID == String("Brightness")) {
			Settings.nFontBrightness  = sVal.toInt();
			SetFontBrightness(Settings.nFontBrightness);
			//Serial.println(sID + ":" + String(Settings.nFontBrightness));
		}
		else if (sID == String("Background")) {
			Settings.nBackBrightness = sVal.toInt();
			SetBackBrightness(Settings.nBackBrightness);
			//Serial.println(sID + ":" + String(Settings.nBackBrightness));
		}
		else if (sID == String("!Cmd")) {
			// Respond to commands
			ProcessCommand((char*)sVal.c_str());
			//if (sVal == String("Set_Defaults")) SaveSettings();
		}
		else if (sID == String("!Req")) {
			// Respond to state requests
			if (sVal == String("news")) {
				//Serial.println("sending news...");

				sOutputBuffer = "{\"ID\":\"stats\",\"Value\":\"" + String(g_sStatusMsg) + "\"}";
				webSocket.sendTXT(num, sOutputBuffer);

				sOutputBuffer = "{\"ID\":\"MessageSelect\",\"Value\":\"" + String(g_nCurrentMessage + 1) + "\"}";
				webSocket.sendTXT(num, sOutputBuffer);

				sOutputBuffer = "{\"ID\":\"Brightness\",\"Value\":\"" + String(Settings.nFontBrightness) + "\"}";
				webSocket.sendTXT(num, sOutputBuffer);

				sOutputBuffer = "{\"ID\":\"Background\",\"Value\":\"" + String(Settings.nBackBrightness) + "\"}";
				webSocket.sendTXT(num, sOutputBuffer);

				sOutputBuffer = "{\"ID\":\"M_1\",\"Value\":\"" + String(Settings.sMessage[g_nCurrentMessage]) + "\"}";
				webSocket.sendTXT(num, sOutputBuffer);

				sOutputBuffer = "{\"ID\":\"A_1\",\"Value\":\"" + String(Settings.sFormat[g_nCurrentMessage]) + "\"}";
				webSocket.sendTXT(num, sOutputBuffer);
			}
			else if (sVal == String("stats")) {
				sOutputBuffer = "{\"ID\":\"" + sVal + "\",\"Value\":\"" + String(g_sStatusMsg) + "\"}";
				webSocket.sendTXT(num, sOutputBuffer);
				//Serial.println(sOutputBuffer);
			}
			else if (sVal == String("MessageSelect")) {
				sOutputBuffer = "{\"ID\":\"" + sVal + "\",\"Value\":\"" + String(g_nCurrentMessage + 1) + "\"}";
				webSocket.sendTXT(num, sOutputBuffer);
				//Serial.println(sOutputBuffer);
			}
			else if (sVal == String("Brightness")) {
				sOutputBuffer = "{\"ID\":\"" + sVal + "\",\"Value\":\"" + String(Settings.nFontBrightness) + "\"}";
				webSocket.sendTXT(num, sOutputBuffer);
				//Serial.println(sOutputBuffer);
			}
			else if (sVal == String("Background")) {
				sOutputBuffer = "{\"ID\":\"" + sVal + "\",\"Value\":\"" + String(Settings.nBackBrightness) + "\"}";
				webSocket.sendTXT(num, sOutputBuffer);
				//Serial.println(sOutputBuffer);
			}
		}
		break;
	}
	digitalWrite(LED_BUILTIN, HIGH);
}

//	StartWiFi_Client()
//
bool StartWiFi_Client( void) {

	const char* ssid = "Chandra";
	const char* password = "farflungdatta";

	Serial.println("StartWiFi_Client()");

	WiFi.hostname(hostName);
	WiFi.mode(WIFI_STA);

	// wifi client
	unsigned long ulTimeOut = millis() + WIFI_TIMEOUT * 1000;
	WiFi.begin(ssid, password);
	// Wait for the Wi-Fi to connect
	while (WiFi.status() != WL_CONNECTED) {
		delay(500);
		if (ulTimeOut < millis()) {
			ulTimeOut = 0; // use this to signal time out, would be non zero if connected, zero if not
			break;
		}
	}
	if (ulTimeOut == 0) {

		// second attempt
		WiFi.disconnect();

		digitalWrite(LED_BUILTIN, HIGH); delay(250);
		digitalWrite(LED_BUILTIN, LOW);	delay(250);

		digitalWrite(LED_BUILTIN, HIGH); delay(250);
		digitalWrite(LED_BUILTIN, LOW);	delay(250);

		digitalWrite(LED_BUILTIN, HIGH); delay(250);
		digitalWrite(LED_BUILTIN, LOW);	delay(250);

		ulTimeOut = millis() + .5 * 60 * 1000;
		WiFi.begin(ssid, password);

		// Wait for the Wi-Fi to connect
		while (WiFi.status() != WL_CONNECTED) {
			delay(500);
			if (ulTimeOut < millis()) {
				ulTimeOut = 0; // use this to signal time out
				break;
			}
		}
	}

	IPAddress IP = WiFi.localIP();
	Serial.print("Local IP address: "); Serial.println(IP);

	Serial.printf("http://%s\r\n", hostName);

	// would be non zero if connected, zero if not
	return ulTimeOut == 0 ? false : true;
}

//	StartWiFi_AP()
//
bool StartWiFi_AP(void) {

	const char* ssid = "FireFLY LightBrush";
	const char* password = "fireflypov";

	Serial.println("StartWiFi_AP()");
	Serial.setDebugOutput(true);

	WiFi.mode(WIFI_AP);

	// Remove the password parameter, if you want the AP (Access Point) to be open
	bool retval = WiFi.softAP(ssid, password);
	delay(500);
	Serial.printf("WiFi.softAP(ssid, password) returned %d\r\n", retval);

	IPAddress IP = WiFi.softAPIP();
	Serial.print("Server IP address: "); Serial.println(IP);

	dnsServer.start(DNS_PORT, hostName, WiFi.softAPIP());
	Serial.printf("http://%s\r\n", hostName);

	return retval;
}

// Start the SPIFFS and list all contents
void startSPIFFS() {

    // Start the SPI Flash File System (SPIFFS)
	SPIFFS.begin();
	if (!SPIFFS.begin()) {
		Serial.println("An Error has occurred while mounting SPIFFS");
		return;
	}
	Serial.println("SPIFFS started. Contents:");
	{
		Dir dir = SPIFFS.openDir("/");
		// List the file system contents
		while (dir.next()) {
			String fileName = dir.fileName();
			size_t fileSize = dir.fileSize();
			Serial.printf("\tFS File: %s, size: %s\r\n", fileName.c_str(), formatBytes(fileSize).c_str());
		}
		Serial.printf("\n");
	}
}

//	StartWebSite
//
void StartWebSite(void) {

	// Route for root / web page
	server.on("/", HTTP_GET, [](AsyncWebServerRequest *request) {
		digitalWrite(LED_BUILTIN, LOW);
		//Serial.print("server.on ");  Serial.println(request->url());
		request->send(SPIFFS, "/index.htm", String(), false, processor);
		digitalWrite(LED_BUILTIN, HIGH);
	});

	server.on("/settings.htm", HTTP_GET, [](AsyncWebServerRequest *request) {
		//Serial.print("server.on ");  Serial.println(request->url());
		request->send(SPIFFS, request->url(), String(), false, processor);
	});

/*	server.on("/stats", HTTP_GET, [](AsyncWebServerRequest *request) {
		//Serial.println("server.on /stats");
		request->send(200, "text/plain", "stats");
	});*/

	// handle any unbound requests
	server.onNotFound([](AsyncWebServerRequest *request) {
		digitalWrite(LED_BUILTIN, LOW);
		if (SPIFFS.exists(request->url())) {
			// file exists, send it
			//Serial.print("serving "); Serial.println(request->url());
			request->send(SPIFFS, request->url(), String(), false);
		}
		else {
			// does not exist, send not found
			Serial.print("ERROR 404 "); Serial.println(request->url());
			request->send(404, "text/plain", "ERROR 404, Not Found.\n\n");
		}
		digitalWrite(LED_BUILTIN, HIGH);
	});

	// Start server
	server.begin();
	Serial.println("Web server started.");
}

// Templates processer
String processor(const String& var) {
	if (var == "STATS") {
		return String(g_sStatusMsg);
	}
	else if (var == "NumMessages") {
		return String(Settings.nNumMessages);
	}
	else if (var == "MessageSelect") {
		return String(g_nCurrentMessage + 1);
	}
	else if (var == "Brightness") {
		if (Settings.nFontBrightness == 0 ) return "Off";
		else if (Settings.nFontBrightness == 10) return "Full";
			else return String(Settings.nFontBrightness);
	}
	else if (var == "Background") {
		if (Settings.nBackBrightness == 0) return "Off";
		else if (Settings.nBackBrightness == 10) return "Full";
		else return String(Settings.nBackBrightness);
	}
	else if (var == "Min_Frame_Rate") {
		return String(Settings.nMinFrameRate);
	}
	else if (var == "Max_Frame_Rate") {
		return String(Settings.nMaxFrameRate);
	}
	else if (var == "Num_Pixels") {
		return String(Settings.nNumPixels);
	}
	else if (var == "Frame_Rate_Pin") {
		return String(Settings.nFrameRatePin);
	}
	else if (var == "Full_Time_Nav") {
		return String(Settings.nFullTimeNav);
	}
	else if (var == "M_1") {
		return String(Settings.sMessage[g_nCurrentMessage]);
	}
	else if (var == "A_1") {
		return String(Settings.sFormat[g_nCurrentMessage]);
	}
	else {
		Serial.print("processor: %"); Serial.print(var); Serial.println("% not found.");
		return var;
	}
	//document.getElementById('Alarm_Active').style.backgroundColor = '#999';
	//document.getElementById('Thresh_Humidity').className = 'disabled';
	//document.getElementById('Thresh_Humidity').disabled = true;
}

// ResetMessage
//
void ResetMessage() {

	int n;
	int nCharNum = 0;

	Settings.nDefaultMessage = g_nCurrentMessage;
	
	// set index and char pointer to beginning
	g_nCharNum = 0;
	g_nCurrentChar = constrain(Settings.sMessage[g_nCurrentMessage][g_nCharNum] - g_nASCIIStart, 0, g_nASCIIEnd - g_nASCIIStart);
	g_nColumnPtr = CharacterMap[g_nCurrentChar];
	g_nCharWidth = pgm_read_dword(g_nColumnPtr);
	g_nColumnNum = 1;

	// set format defaults
	SetBackBrightness(Settings.nBackBrightness);
	SetFontBrightness(Settings.nFontBrightness);
	FastLED.setBrightness(255);
	g_nEffectID = 0;
	g_nEffectPalleteID = 0;
	g_nAnimFrames = 256;

	// read format string
	n = strlen(Settings.sFormat[g_nCurrentMessage]);
	for (nCharNum = 0; (size_t)nCharNum < strlen(Settings.sFormat[g_nCurrentMessage]); nCharNum++) {
		if (Settings.sFormat[g_nCurrentMessage][nCharNum] == '/') {
			char nChar = Settings.sFormat[g_nCurrentMessage][nCharNum + 1];
			// \Bn
			if (nChar == 'b' || nChar == 'B') {
				n = constrain(Settings.sFormat[g_nCurrentMessage][nCharNum + 2] - '0', 0, 9);
				SetFontBrightness(n);
				nCharNum += 2;
			}

			// \Nn
			else if (nChar == 'n' || nChar == 'N') {
				n = constrain(Settings.sFormat[g_nCurrentMessage][nCharNum + 2] - '0', 0, 9);
				SetBackBrightness(n);
				nCharNum += 2;
			}

			// \En
			else if (nChar == 'e' || nChar == 'E') {
				n = constrain(Settings.sFormat[g_nCurrentMessage][nCharNum + 2] - '0', 0, 9);
				g_nEffectID = n;
				nCharNum += 2;
			}

			// \Pn
			else if (nChar == 'p' || nChar == 'P') {
				n = constrain(Settings.sFormat[g_nCurrentMessage][nCharNum + 2] - '0', 0, 9);
				g_nEffectPalleteID = n;
				nCharNum += 2;
			}

			// \Gn
/*
			else if (nChar == 'g' || nChar == 'G') {
				n = constrain(Settings.sFormat[g_nCurrentMessage][nCharNum + 2] - '0', 0, 9);
				// set graphic image number (coded as a negative g_nEffectID number)
				g_nEffectID = -1 * n;
				switch (abs(g_nEffectID)) {
				case 1:
					g_nAnimFrames = oBitmap_width + Settings.nInterCharFrameGap * 6;

					// setup scaling map
					uint16_t nSegmentWidth = Settings.nNumPixels / Settings.nNumSegments;
					uint16_t jprime;
					for (uint8_t nSegment = 0; nSegment < Settings.nNumSegments; nSegment++) {
						for (uint16_t j = 0; j < nSegmentWidth; j++) {
							jprime = Settings.sSegmentSetup[nSegment] == '0' ? j : nSegmentWidth - j - 1;
							nBitmapScalarMap[nSegment * nSegmentWidth + j] = (uint16_t) map(jprime, 0, nSegmentWidth, 0, oBitmap_height);
						}
					}
				}
				nCharNum += 2;
			}
			*/
		}
	}
}


// SerialEvent()
//
void SerialEvent() {
	static char g_sCommandBuffer[40] = { 0 };
	static uint8_t g_nCommandLength = 0;

	char sInputChar = 0;   // for incoming serial data

	// read the incoming char
	sInputChar = Serial.read();

	switch (sInputChar) {
	case '\r':  // Carriage return /Enter 0x0d
		if (g_nCommandLength > 0) {
			Serial.println();
			ProcessCommand(g_sCommandBuffer);
			Serial.flush();
			g_nCommandLength = 0;
		}

		//show prompt
		Serial.println();
		Serial.print("fireFly POV>");
		break;

	case 127: // Backspace
		if (g_nCommandLength > 0) {
			Serial.print(sInputChar);
			//Serial.print( " "); Serial.print( sInputChar);
			g_sCommandBuffer[--g_nCommandLength] = '\0';
		}
		break;

	default:
		// if sInputChar is a visible (non-escape code) character then we append it to our command line buffer
		if ((int)sInputChar > 31 && (int)sInputChar < 127) {
			if (g_nCommandLength< sizeof(g_sCommandBuffer)) {
				// echo char
				Serial.print(sInputChar);
				g_sCommandBuffer[g_nCommandLength] = sInputChar;
				g_sCommandBuffer[++g_nCommandLength] = '\0';
			}
		}
		break;
	}
}

// ProcessCommand
//
void ProcessCommand(char *sCommand) {

	int n;
	int n1;

	switch (sCommand[0]) {
	case 'A':
	case 'a':
		// format command
		n = constrain(sCommand[1] - '1', 0, 8);  // convert the ascii number to 0-4 for using as index
		if (sCommand[2] == '=') {
			// set message format n to abc
			if (strlen(&sCommand[3]) > sizeof(Settings.sFormat[n]) - 1) {
				Serial.print(F("Format too long, max length is ")); Serial.print(sizeof(Settings.sFormat[n]) - 1); Serial.println(F(" chars."));
			}
			else {
				strcpy(Settings.sFormat[n], &sCommand[3]);
				Serial.print("A"); Serial.print(n + 1); Serial.print("=\""); Serial.print(Settings.sFormat[n]); Serial.println("\"");
			}
		}
		ResetMessage();
		break;

	case 'B':
	case 'b':
		// Set font brightness
		n = constrain(sCommand[1] - '0', 0, 9);
		Settings.nFontBrightness = n;
		SetFontBrightness(Settings.nFontBrightness);

		Serial.print(F("Font brightness set to ")); Serial.println(Settings.nFontBrightness);
		break;

	case 'c':
	case 'C':
		CalibrateInputs();
		break;

	case 'd':
	case 'D':
		// Load Defaults
		LoadDefaults();
		Serial.println(F("Loaded default settings."));
		ResetMessage();
		break;

	case 'e':
	case 'E':
		n = constrain(atoi(&sCommand[2]), 1, 420);
			Settings.nNumPixels = n;
			Serial.print(F("NumPixels set to ")); Serial.println(n);
			break;

	case 'f':
	case 'F':
		n = constrain(atoi(&sCommand[3]), 1, 420);
		switch (sCommand[1]) {
		case 'n':
		case 'N':
			Settings.nMinFrameRate = n;
			Serial.print(F("Min frame rate set to ")); Serial.println(n);
			break;

		case 'x':
		case 'X':
			Settings.nMaxFrameRate = n;
			Serial.print(F("Max frame rate set to ")); Serial.println(n);
			g_nFrameRate = Settings.nMaxFrameRate;
			break;
		}
		// make sure frame rate is inside new constraints
		g_nFrameRate = constrain(g_nFrameRate, Settings.nMinFrameRate, Settings.nMaxFrameRate);
		break;

	case 'G':
	case 'g':
		// Set character frame gap (space between characters)
		n = constrain(sCommand[1] - '0', 1, 9);
		Settings.nInterCharFrameGap = n;
		Serial.print(F("Character frame gap set to ")); Serial.println(n);
		break;

	case 'i':
	case 'I':
		// Set orientation inverts
		n = constrain(sCommand[1] - '0', 0, 1);
		n1 = constrain(sCommand[2] - '0', 0, 1);
		Settings.nOrientationInverts = n * 2 + n1;
		g_nLastPWMOrientationValue = 0;  // force recalc of orientation variable
		Serial.print(F("Inverts set to: ")); Serial.print(n); Serial.println(n1);
		ResetMessage();
		break;

	case 'l':
	case 'L':
		Serial.println(F("Current Settings:"));
		Serial.println();
		Serial.print(F("Font Brightness = ")); Serial.println(Settings.nFontBrightness);
		Serial.print(F("Back Brightness = ")); Serial.println(Settings.nBackBrightness);
		Serial.print(F("Min Frame Rate  = ")); Serial.println(Settings.nMinFrameRate);
		Serial.print(F("Max Frame Rate  = ")); Serial.println(Settings.nMaxFrameRate);
		Serial.print(F("Number of Pixels= ")); Serial.println(Settings.nNumPixels);
		Serial.print(F("Character Gap   = ")); Serial.println(Settings.nInterCharFrameGap);
		Serial.println();

		Serial.print(F("Frame Rate Pin       = "));
		if (Settings.nFrameRatePin > 0) {
			Serial.print(F("D"));
			Serial.print(Settings.nFrameRatePin);
			Serial.print(F(" [")); Serial.print(Calibrations.nFrameRate_LowVal); Serial.print("-"); Serial.print(Calibrations.nFrameRate_HighVal); Serial.println("]");
		}
		else {
			Serial.println(F("disabled"));
		}

		Serial.print(F("Message Select Pin   = "));
		if (Settings.nMessageSelectPin > 0) {
			Serial.print(F("D"));
			Serial.print(Settings.nMessageSelectPin);
			Serial.print(F(" [")); Serial.print(Calibrations.nMessageSelect_LowVal); Serial.print("-"); Serial.print(Calibrations.nMessageSelect_HighVal); Serial.println("]");
		}
		else {
			Serial.print(F("A"));
			Serial.print(abs(Settings.nMessageSelectPin));
			Serial.print(F(" [")); Serial.print(Calibrations.nMessageSelect_LowVal); Serial.print("-"); Serial.print(Calibrations.nMessageSelect_HighVal); Serial.println("]");
		}


		Serial.print(F("Orientation Pin      = "));
		if (Settings.nOrientationPin > 0) {
			Serial.print(F("D"));
			Serial.print(Settings.nOrientationPin);
			Serial.print(F(" [")); Serial.print(Calibrations.nOrientation_LowVal); Serial.print("-"); Serial.print(Calibrations.nOrientation_HighVal); Serial.println("]");
		}
		else {
			Serial.println(F("disabled"));
		}

		Serial.print(F("Render Inhibit       = A2")); Serial.println(" (ground = pause)");
		Serial.print(F("Orientation Deadzone = ")); Serial.print(Settings.nOrientationDeadZone); Serial.println("%");

		n = (Settings.nOrientationInverts & 2) >> 1;
		n1 = Settings.nOrientationInverts & 1;
		Serial.print(F("Orientation Inverts  = ")); Serial.print(n); Serial.print(n1); Serial.print(" (Current Orientation: "); Serial.print(g_nOrientation); Serial.println(")");

		Serial.print(F("Strip Type           = ")); Serial.print(Settings.nStripType);
		switch (Settings.nStripType) {
		case aWS2812B:
			Serial.println(F(" (WS2812B)"));
			break;
		case aLPD8806:
			Serial.println(F(" (LPD8806)"));
			break;
		}

		Serial.print(F("Pixel Multiplier     = ")); Serial.println(Settings.nPixelsMulti);
		Serial.print(F("Full Time Nav        = ")); Serial.println(Settings.nFullTimeNav);

		Serial.println();
		Serial.print(F("Active Messages = ")); Serial.println(Settings.nNumMessages);
		for (int i = 0; i < Settings.nNumMessages; i++) {
			if (i == g_nCurrentMessage) Serial.print(F("*M")); else Serial.print(" M");
			Serial.print(i + 1); Serial.print("=\""); Serial.print(Settings.sMessage[i]); Serial.print("\"");

			int iMax = sizeof(Settings.sMessage[i]) - strlen(Settings.sMessage[i]);
			for (int i1 = 0; i1<iMax; i1++) Serial.print(" ");
			Serial.print(F(" >> ")); Serial.print(Settings.sFormat[i]);

			Serial.println();
		}
		//Serial.println();
		// report actual frame rate
		Serial.print(F("Current Frame Rate: ")); Serial.print(FastLED.getFPS()); Serial.println(F(" fps"));
		//Serial.print(F("S ")); Serial.println(SPARKING);
		//Serial.print(F("C ")); Serial.println(COOLING);
		break;

	case 'M':
	case 'm':
		if (sCommand[1] == 'A' || sCommand[1] == 'a') {
			// set message actives count
			Settings.nNumMessages = constrain(sCommand[3] - '0', 1, 9);
			Serial.print(F("Active messages set to ")); Serial.println(Settings.nNumMessages);
		}
		else {
			// message command
			n = constrain(sCommand[1] - '1', 0, 8);  // convert the ascii number to 0-8 for using as index
			
			// are we setting a message or selecting?  look for that '=' sign at position 3
			if (sCommand[2] == '=') {
				// set message n to abc
				if (strlen(&sCommand[3]) > sizeof(Settings.sMessage[n]) - 1) {
					Serial.print(F("Message too long, max length is ")); Serial.print(sizeof(Settings.sMessage[n]) - 1); Serial.println(F(" chars."));
				}
				else {
					strcpy(Settings.sMessage[n], &sCommand[3]);
					Serial.print("M"); Serial.print(n + 1); Serial.print("=\""); Serial.print(Settings.sMessage[n]); Serial.println("\"");
				}
			}
			else {
				// selecting message n
				g_nCurrentMessage = n;
				Serial.print(F("Message ")); Serial.print(n + 1); Serial.println(F(" selected."));
			}
		}
		ResetMessage();
		break;

	case 'N':
	case 'n':
		// Set Nav brightness
		Settings.nBackBrightness = constrain(sCommand[1] - '0', 0, 9);
		SetBackBrightness(Settings.nBackBrightness);
		Serial.print(F("BackBrightness set to ")); Serial.println(Settings.nBackBrightness);
		break;

	case 'p':
	case 'P':
		n = constrain(atoi(&sCommand[3]), -15, 13);
		if (n == 1) {
			Serial.println(F("pin 1 used by SPI."));
		}
		else {
			switch (sCommand[1]) {
			case 'f':
			case 'F':
				Settings.nFrameRatePin = n;
				Serial.print(F("FrameRate Pin set to ")); Serial.println(n);
				if (Settings.nFrameRatePin > 0) pinMode(Settings.nFrameRatePin, INPUT);
				break;
			case 'm':
			case 'M':
				Settings.nMessageSelectPin = n;
				Serial.print(F("MessageSelect Pin set to ")); Serial.println(n);
				if (Settings.nMessageSelectPin > 0) {
					pinMode(Settings.nMessageSelectPin, INPUT);
					Calibrations.nMessageSelect_LowVal = 1000;
					Calibrations.nMessageSelect_HighVal = 2000;
				}
				else {
					Calibrations.nMessageSelect_LowVal = 0;
					Calibrations.nMessageSelect_HighVal = 1024;
				}
				SaveCalibrations();
				break;
			case 'o':
			case 'O':
				Settings.nOrientationPin = n;
				Serial.print(F("Orientation Pin set to ")); Serial.println(n);
				if (Settings.nOrientationPin > 0) pinMode(Settings.nOrientationPin, INPUT);
				break;
			}
		}
		break;

	case 'r':
	case 'R':
		LoadSettings();
		Serial.println(F("Settings reloaded."));
		ResetMessage();
		break;

	case 's':
	case 'S':
		SaveSettings();
		Serial.println(F("Settings saved."));
		break;

	case 't':
	case 'T':
		switch (sCommand[1]) {
		case 's':
		case 'S':
			// set strip type
			// aWS2812B = 1,
			// aLPD8806 = 2,
			Settings.nStripType = (STRIP_TYPE)constrain(sCommand[2] - '0', aWS2812B, aLPD8806);
			InitStrip();

			Serial.print(F("Strip Type set to ")); Serial.println(Settings.nStripType);
			break;

		case 'x':
		case 'X':
			// clear the strip
			for (n = 0; n < g_nFontPixels; n++) {
				SetPixel(n, CRGB::Black);
			}
			ShowStrip();

			// set new multiplier
			Settings.nPixelsMulti = constrain(sCommand[2] - '0', 1, 4);
			//InitStrip();

			Serial.print(F("Pixel Multi set to ")); Serial.println(Settings.nPixelsMulti);
			break;
		}
		break;

	case 'V':
	case 'v':
		// Set full time nav
		Settings.nFullTimeNav = constrain(sCommand[1] - '0', 0, 1);
		Serial.print(F("Nav lights ")); Serial.println(Settings.nFullTimeNav ? "On" : "Off");
		break;

	case 'z':
	case 'Z':
		n = constrain(atoi(&sCommand[2]), 0, 10);
		Settings.nOrientationDeadZone = n;
		Serial.print(F("Orientation deadzone set to ")); Serial.print(n); Serial.println(F(" percent."));
		break;

	case 'h':
	case '?':
		Serial.print(F("fireFly POV - By Buck McGibbony and Paul Drucker - Version ")); Serial.println(VERSION);
		Serial.println();
		Serial.println(F("   Bx     - Set font brightness to x (0-9)"));
		Serial.println(F("   Nx     - Set background brightness to x (0-9)"));
		Serial.println(F("   Gx     - Set character frame gap (1-9)"));
		Serial.println(F("   E=x    - Set number of pixels to x"));
		Serial.println(F("   FN=x   - Set frame rate min to x (1-320 fps)"));
		Serial.println(F("   FX=x   - Set frame rate max to x (1-320 fps)"));
		Serial.println(F("   Mx=abc - Set message x (1-9) to abc, no quotes"));
		Serial.println(F("   Ax=abc - Set format x (1-9) abc, no quotes"));
		Serial.println(F("            /Bn - Font brightness"));
		Serial.println(F("            /Nn - Bkgrnd brightness"));
		Serial.println(F("            /En - Bkgrnd Effect - 0=Black, 1=Nav, 2=Rainbow, 3=Thrust"));
		Serial.println(F("            /Pn - Effect Pallette - 0=Default, 1-6"));
		Serial.println(F("   Mx     - Select message x (1-5)"));
		Serial.println(F("   MA=x   - Set number of messages to be active to x (1-9)"));
		Serial.println(F("   PF=x   - Set frame rate pin to x (0 for none)"));
		Serial.println(F("   PM=x   - Set message select pin to x (0 - -5 for A0 - A5)"));
		Serial.println(F("   PO=x   - Set orientation pin to x (0 for none)"));
		Serial.println(F("   Z=x    - Set orientation deadzone to x (% full range)"));
		Serial.println(F("   Ixy    - Set paint inverts x = 0(L->R) or 1(R->L)"));
		Serial.println(F("            and strip orientation y = 0(up) or 1(down)"));
		Serial.println(F("   TXx    - Set Pixel Multiplier to x (1-4)"));
		Serial.println(F("   TSx    - Set Strip Type to x (1=WS2812B, 2=LPD8806)"));
		Serial.println(F("   Vx     - Set full time nav lights (0=off, 1=on)"));
		Serial.println(F("   C      - Start calibration sequence"));
		Serial.println(F("   L      - List settings"));
		Serial.println(F("   D      - Load default settings"));
		Serial.println(F("   R      - Reload settings from EEPROM"));
		Serial.println(F("   S      - Save settings to EEPROM"));
		break;

	default:
		Serial.println(F("Command unrecognized.  Type '?' or 'h' for help."));
		break;
	}

}


//  UpdateInputs()
//
void UpdateInputs() {

	static unsigned long s_nLastMessageSelectValue = 0;
	static unsigned long s_nLastPWMFrameRateValue = 0;
	static byte s_nCurrentInputCheck = 0;

	int n;
	int nDeltaC;
	unsigned long n_Raw;

	switch (s_nCurrentInputCheck) {
	case 0:
		// frame rate from PWM input?
		if (Settings.nFrameRatePin > 0) {
			n_Raw = pulseIn(Settings.nFrameRatePin, HIGH, PWM_TIMEOUT);
			if (n_Raw == 0) n_Raw = Calibrations.nFrameRate_HighVal;

			if (abs(s_nLastPWMFrameRateValue - n_Raw) > PWM_NOISEFLOOR) {
				s_nLastPWMFrameRateValue = n_Raw;
				g_nFrameRate = map(n_Raw, Calibrations.nFrameRate_LowVal, Calibrations.nFrameRate_HighVal, Settings.nMinFrameRate, Settings.nMaxFrameRate + 1);

				// calculate plasma settings
				if (g_nEffectID == 3) {
					//SPARKING = SPARKING_MIN;
					//COOLING = COOLING_MAX;
					SPARKING = map(n_Raw, Calibrations.nFrameRate_LowVal, Calibrations.nFrameRate_HighVal, SPARKING_MIN, SPARKING_MAX);
					COOLING = map(n_Raw, Calibrations.nFrameRate_LowVal, Calibrations.nFrameRate_HighVal, COOLING_MAX, COOLING_MIN);
				}
			}

		}
		else {
			g_nFrameRate = Settings.nMaxFrameRate; // no PWM sensing just use Settings.nMaxFrameRate
			SPARKING = SPARKING_MAX;
			COOLING = COOLING_MIN;
		}


		s_nCurrentInputCheck = 1;
		break;

	case 1:
		// Message select
		if (Settings.nMessageSelectPin > 0) {
			n_Raw = pulseIn(Settings.nMessageSelectPin, HIGH, PWM_TIMEOUT); // get PWM value
		}
		else {
			n_Raw = analogRead(abs(Settings.nMessageSelectPin));  // get analog value from pin Ax
		}
		if (n_Raw == 0) n_Raw = Calibrations.nMessageSelect_LowVal;

		if (abs(s_nLastMessageSelectValue - n_Raw) > PWM_NOISEFLOOR) { // this filters the noise
			s_nLastMessageSelectValue = n_Raw;
			n = constrain(map(n_Raw, Calibrations.nMessageSelect_LowVal, Calibrations.nMessageSelect_HighVal, 0, Settings.nNumMessages), 0, Settings.nNumMessages - 1);
			if (g_nCurrentMessage != n) {
				g_nCurrentMessage = n;
				ResetMessage();
			}
		}
		s_nCurrentInputCheck = 2;
		break;

	case 2:
		// Orientation control from PWM input
		if (Settings.nOrientationPin > 0) {
			n_Raw = pulseIn(Settings.nOrientationPin, HIGH, PWM_TIMEOUT); // no constrain here
			if (n_Raw == 0) n_Raw = Calibrations.nOrientation_HighVal;

			if (abs(g_nLastPWMOrientationValue - n_Raw) > PWM_NOISEFLOOR) {
				g_nLastPWMOrientationValue = n_Raw;
				nDeltaC = map(n_Raw, Calibrations.nOrientation_LowVal, Calibrations.nOrientation_HighVal, 0, 101) - Calibrations.nOrientation_Normal; // Use normal as dead center
				if (abs(nDeltaC) > Settings.nOrientationDeadZone) {
					// set g_nOrientation based on whether DeltaC is positive or negative
					g_nOrientation = nDeltaC < 0 ? LOW : HIGH;
				}
			}
		}
		s_nCurrentInputCheck = 0;
		break;

	}
}

// Calibrate PWM inputs
//
void CalibrateInputs() {

	unsigned long n_Raw;
	unsigned long ulTimeNow;
	unsigned long n_LowVal;
	unsigned long n_HighVal;
	const int nTimeout = 7000; // Calibration timeout in millis

	//	void *SettingsBlockStart = &Settings;

	Serial.print(F("PWM input calibration initiated.  Each step will last ")); Serial.print(nTimeout / 1000); Serial.println(F(" seconds."));

	if (Settings.nFrameRatePin > 0) {
		Serial.println();
		Serial.print(F(">> Please cycle the FRAME RATE input on pin ")); Serial.println(Settings.nFrameRatePin);

		n_LowVal = 1500;
		n_HighVal = 1500;
		ulTimeNow = millis(); // record entrance time
		do {
			n_Raw = pulseIn(Settings.nFrameRatePin, HIGH, PWM_TIMEOUT);
			if (n_Raw < n_LowVal) n_LowVal = n_Raw;
			else if (n_Raw > n_HighVal) n_HighVal = n_Raw;
		} while (millis() - ulTimeNow < nTimeout);

		// did we get some useful data?
		if (n_LowVal == 1500 || n_HighVal == 1500) {
			Serial.print(F("TIMEOUT: no PWM input on pin ")); Serial.println(Settings.nFrameRatePin);
		}
		// yes we did
		else {
			Calibrations.nFrameRate_LowVal = n_LowVal;
			Calibrations.nFrameRate_HighVal = n_HighVal;
			Serial.print(F("Frame Rate PWM extents [")); Serial.print(Calibrations.nFrameRate_LowVal); Serial.print("-"); Serial.print(Calibrations.nFrameRate_HighVal); Serial.println("]");
		}
	}

	Serial.println();
	Serial.print(F(">> Please cycle MESSAGE SELECT on pin ")); Serial.println(Settings.nMessageSelectPin);

	ulTimeNow = millis(); // record entrance time

	if (Settings.nMessageSelectPin > 0) {
		n_LowVal = 1500;
		n_HighVal = 1500;
		do {
			n_Raw = pulseIn(Settings.nMessageSelectPin, HIGH, PWM_TIMEOUT);
			if (n_Raw < n_LowVal) n_LowVal = n_Raw;
			else if (n_Raw > n_HighVal) n_HighVal = n_Raw;
		} while (millis() - ulTimeNow < nTimeout);
	}
	else {
		n_LowVal = 512;
		n_HighVal = 512;
		do {
			n_Raw = analogRead(abs(Settings.nMessageSelectPin));
			if (n_Raw < n_LowVal) n_LowVal = n_Raw;
			else if (n_Raw > n_HighVal) n_HighVal = n_Raw;
		} while (millis() - ulTimeNow < nTimeout);
	}

	// did we get some useful data?
	if (n_LowVal == 1500 || n_HighVal == 1500 || n_LowVal == 512 || n_HighVal == 512) {
		Serial.print(F("TIMEOUT: no input on pin ")); Serial.println(Settings.nMessageSelectPin);
	}
	// yes we did
	else {
		Calibrations.nMessageSelect_LowVal = n_LowVal;
		Calibrations.nMessageSelect_HighVal = n_HighVal;
		Serial.print(F("Message Select extents were [")); Serial.print(Calibrations.nMessageSelect_LowVal); Serial.print("-"); Serial.print(Calibrations.nMessageSelect_HighVal); Serial.println("]");
	}

	if (Settings.nOrientationPin > 0) {
		Serial.println();
		Serial.print(F(">> Please cycle ORIENTATION on pin ")); Serial.println(Settings.nOrientationPin);

		n_LowVal = 1500;
		n_HighVal = 1500;
		ulTimeNow = millis(); // record entrance time
		do {
			n_Raw = pulseIn(Settings.nOrientationPin, HIGH, PWM_TIMEOUT);
			if (n_Raw < n_LowVal) n_LowVal = n_Raw;
			else if (n_Raw > n_HighVal) n_HighVal = n_Raw;
		} while (millis() - ulTimeNow < nTimeout);

		// did we get some useful data?
		if (n_LowVal == 1500 || n_HighVal == 1500) {
			Serial.print(F("TIMEOUT: no PWM input on pin ")); Serial.println(Settings.nOrientationPin);
		}
		// yes we did
		else {
			Calibrations.nOrientation_LowVal = n_LowVal;
			Calibrations.nOrientation_HighVal = n_HighVal;

			// sample current position to get the normal
			Serial.println(F("Setting ORIENTATION normal..."));
			ulTimeNow = millis(); // record entrance time
			do {
				n_Raw = pulseIn(Settings.nOrientationPin, HIGH, PWM_TIMEOUT);
				if (n_Raw < n_LowVal) n_LowVal = n_Raw;
				else if (n_Raw > n_HighVal) n_HighVal = n_Raw;
			} while (millis() - ulTimeNow < nTimeout / 2);

			//get normal value
			n_Raw = pulseIn(Settings.nOrientationPin, HIGH, PWM_TIMEOUT);
			// map the PWM normal value now so we don't have to remap it every time we use it later on
			Calibrations.nOrientation_Normal = map(n_Raw, Calibrations.nOrientation_LowVal, Calibrations.nOrientation_HighVal, 0, 101);
			Serial.print(F("Orientation PWM extents [")); Serial.print(Calibrations.nOrientation_LowVal); Serial.print("-"); Serial.print(Calibrations.nOrientation_HighVal); Serial.print(":"); Serial.print(n_Raw); Serial.println("]");
		}
	}

	// if we made it this far then it must have all worked out
	// lets save the calibration data to EEPROM
	Serial.println(F("Saving calibration data."));
	SaveCalibrations();
}

//	formatBytes
//
//		convert sizes in bytes to KB and MB
//
String formatBytes(size_t bytes) {
	if (bytes < 1024) {
		return String(bytes) + "B";
	}
	else if (bytes < (1024 * 1024)) {
		return String(bytes / 1024.0) + "KB";
	}
	else if (bytes < (1024 * 1024 * 1024)) {
		return String(bytes / 1024.0 / 1024.0) + "MB";
	}
}

