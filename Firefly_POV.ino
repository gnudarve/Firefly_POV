// Firefly POV - Written by Buck McGibbony.  Copyright (C) 2014-2018 - all rights reserved.
//
//

#include <FastLED.h>
#include <avr/pgmspace.h>
#include <avr/eeprom.h>

#define VERSION "1.8"

// attach font generated by POV Font Muncher
#include "Lucida_Console.h"
#define CharacterMap Lucida_Console
#define g_nASCIIStart Lucida_Console_nASCIIStart
#define g_nASCIIEnd Lucida_Console_nASCIIEnd


// setup serial class for bluetooth comms, platform dependant
#if defined(TEENSYDUINO) 
//  --------------- Teensy -----------------
#define BTSerial Serial3

#define DATA_PIN      17
#define CLOCK_PIN     13
#else 
// --------------- Arduino ------------------
#include <SoftwareSerial.h>
SoftwareSerial BTSerial(8, 7); // RX, TX

#define DATA_PIN      11
#define CLOCK_PIN     13
#endif
// serial communication settings
#define USB_BAUD_RATE 115200
#define BT_BAUD_RATE 9600
#define USB_PORT 1
#define BT_PORT 2
#define BOTH_PORTS 3

#define PWM_TIMEOUT 25000UL
#define PWM_NOISEFLOOR 10

#define COOLING_MIN 80
#define COOLING_MAX 180

#define SPARKING_MIN 20
#define SPARKING_MAX 120
#define SPARKING_THRESH .8
//int SPARKING = 90;
//int COOLING = 10;
int SPARKING = SPARKING_MIN;
int COOLING = COOLING_MAX;


// Globals

unsigned long g_ulNextPWMSampleTime = 0;
unsigned long g_ulNextFrameTime = 0;
unsigned long g_nLastPWMFrameRateValue = 0;
unsigned long g_nLastMessageSelectValue = 0;
unsigned long g_nLastPWMOrientationValue = 0;
char g_sCommandBuffer[2][24];
byte g_nCommandLength[2] = {0, 0};
byte g_nCurrentInputCheck = 0;

// render states
unsigned int g_nFrameRate = 0;		// frame rate
byte g_nOrientation = 0;			// letter orientation

byte g_nCurrentMessage = 0;			// message number
int g_nCharNum = 0;					// character number, used as an index into sMessage[]
byte g_nCurrentChar = 0;			// normalized current char ascii, converted to an index into the font* table
const uint32_t *g_nColumnPtr;		// address to the current char and columns 32 bit DWORD of bits
uint32_t g_nCharWidth;				// char width in pixels
int g_nColumnNum;					// column number of char
int g_nAnimSpeed = 2;				// animation speed

byte g_nBackBright;
CRGB g_cFontRender;

int g_nEffectID = 0;				// Background ID number (-1 for NAV override, 0=Black, 1=Navigation, 2=Rainbow, 3=Thruster)
int g_nEffectPalleteID = 0;

// number of RGB LEDs in strand
const uint16_t g_nFontPixels = 32;
const uint16_t g_nStripPixels = g_nFontPixels * 4;

// composition buffer
CRGB g_cPixels[g_nStripPixels];
//CRGB *g_cPixels;
//delete[] g_cPixels;
//g_cPixels = new CRGB[g_nStripPixels];

// PWM Sample rate in cycles per second
const int g_nSampleRate = 30;

enum STRIP_TYPE {
    aWS2812B = 1,
    aLPD8806 = 2,
};


// Settings functions
//
// increment this every time you make ANY change to the Settings or Calibrations structure
// this way we can know when to revert to defaults after a code update
byte SettingsVersion = 4;
struct Settings_t {

	//strip
	STRIP_TYPE nStripType;		// type of LED strip
	unsigned int nPixelsMulti;	// Multiply pixels - each internal pixel fills nPixelsMulti LED pixels on the strip for better long distance viewing and brightness

	// max/min frame rates
	int nMinFrameRate;			// min frame rate
	int nMaxFrameRate;			// max frame rate
	
	// font settings
	byte nInterCharFrameGap;	// this is the number of frames between each char 
	byte nBackBrightness;		// 0-9
	byte nFontBrightness;		// 0-9

	// PWM input settings
	int nFrameRatePin;			// pin for frame rate control, set to 0 for no frame rate control, default frame rate will then be nMaxFrameRate
	int nMessageSelectPin;		// Pin for pattern select control, 0 - -15 for analog inputs along A0-A15
	int nOrientationPin;		// pin for orientation (left to right/right to left {upside down}) control, 0 for no orientation control
	byte nOrientationDeadZone;	// dead zone for orientation flip control, in percent of full range of control
	byte nOrientationInverts;	// invert orientation in relation to control
	byte nFullTimeNav;			// full time nav on tips

	// messages
	byte nNumMessages;			// Number of active messages
	char sMessage[9][33];		// Message array
	char sFormat[9][13];		// Message format string array

} Settings;

struct Calibrations_t {
	int nFrameRate_LowVal;  //default is 1000 (microseconds)
	int nFrameRate_HighVal;  // default is 2000 (microseconds)
	int nMessageSelect_LowVal;  //default is 1000 (microseconds)
	int nMessageSelect_HighVal;  // default is 2000 (microseconds)
	int nOrientation_LowVal;  //default is 1000 (microseconds)
	int nOrientation_HighVal;  // default is 2000 (microseconds)
	int nOrientation_Normal;  // default is 50 (mapped 0-101)
} Calibrations;

// LoadDefaults
//
void LoadDefaults() {

	//Settings.nStripType = aLPD8806;
	Settings.nStripType = aWS2812B;

	Settings.nPixelsMulti = 1;

	Settings.nBackBrightness = 5;	// 0-9
	Settings.nFontBrightness = 8;	// 0-9
	Settings.nMinFrameRate = 90;
	Settings.nMaxFrameRate = 120;
	
	Settings.nInterCharFrameGap = 6;
	Settings.nFrameRatePin = 4;
	Settings.nMessageSelectPin = 2;
	Settings.nOrientationPin = 6;
	Settings.nOrientationDeadZone = 5;
	Settings.nOrientationInverts = 1;
	Settings.nFullTimeNav = true;

	Settings.nNumMessages = 9;
	strcpy( Settings.sMessage[0], " ");
	strcpy( Settings.sMessage[1], " ");
	strcpy( Settings.sMessage[2], " ");
	strcpy( Settings.sMessage[3], " ");
	strcpy( Settings.sMessage[4], " ");
	strcpy( Settings.sMessage[5], " ");
	strcpy( Settings.sMessage[6], " ");
	strcpy( Settings.sMessage[7], "fireFLY    ");
	strcpy( Settings.sMessage[8], " ");

	strcpy( Settings.sFormat[0], "\\e3\\p1");
	strcpy( Settings.sFormat[1], "\\e3\\p2");
	strcpy( Settings.sFormat[2], "\\e3\\p3");
	strcpy( Settings.sFormat[3], "\\e3\\p4");
	strcpy( Settings.sFormat[4], "\\e3\\p5");
	strcpy( Settings.sFormat[5], "\\e3\\p6");
	strcpy( Settings.sFormat[6], "\\e2");
	strcpy( Settings.sFormat[7], "\\e2");
	strcpy( Settings.sFormat[8], "\\e1");

	// global pre-calc vars
	SetBackBrightness( Settings.nBackBrightness);
	SetFontBrightness( Settings.nFontBrightness);

	Calibrations.nFrameRate_LowVal = 1000;
	Calibrations.nFrameRate_HighVal = 2000;
	Calibrations.nMessageSelect_LowVal = 1000;
	Calibrations.nMessageSelect_HighVal = 2000;
	Calibrations.nOrientation_LowVal = 1000;
	Calibrations.nOrientation_HighVal = 2000;
	Calibrations.nOrientation_Normal = 50;

	//save to EEPROM
	SaveSettings();
	SaveCalibrations();
}


// LoadSettings
//
void LoadSettings() {
	
	byte nCurrentSettingsVersion;
	int SettingsBlockStart = sizeof(SettingsVersion);
	int CalibrationsBlockStart = sizeof(SettingsVersion) + sizeof(Settings);

#if defined(__MKL26Z64__)
	LoadDefaults();
#else
	// first load the settings version and check for mis-match
	eeprom_read_block((void*)&nCurrentSettingsVersion, (void*)0, sizeof(nCurrentSettingsVersion));
	if( nCurrentSettingsVersion != SettingsVersion) {
		LoadDefaults();
	}
	else {
		// load settings
		eeprom_read_block((void*)&Settings, (void*)SettingsBlockStart, sizeof(Settings));
		// load calibrations
		eeprom_read_block((void*)&Calibrations, (void*)CalibrationsBlockStart, sizeof(Calibrations));
	}
#endif

	// global pre-calc vars
	SetBackBrightness( Settings.nBackBrightness);
	SetFontBrightness( Settings.nFontBrightness);
}

// SaveSettings
//
void SaveSettings() {
	int SettingsBlockStart = sizeof(SettingsVersion);

	// save settings version
	eeprom_write_block((void*)&SettingsVersion, (void*)0, sizeof(SettingsVersion));
	// save settings
	eeprom_write_block((void*)&Settings, (void*)SettingsBlockStart, sizeof(Settings));
}


// SaveCalibrations
//
void SaveCalibrations() {
	// save PWM calibration values
	int CalibrationsBlockStart = sizeof(SettingsVersion) + sizeof(Settings);
	eeprom_write_block((void*)&Calibrations, (void*)CalibrationsBlockStart, sizeof(Calibrations));
}


// InitStrip
//
void InitStrip() {

	// setup strip
	switch ( Settings.nStripType) {
		case aWS2812B:
			FastLED.addLeds<WS2812B, DATA_PIN, GRB>(g_cPixels, g_nStripPixels).setCorrection(TypicalLEDStrip);
			break;

		case aLPD8806:
			FastLED.addLeds<LPD8806, DATA_PIN, CLOCK_PIN, RGB>(g_cPixels, g_nStripPixels).setCorrection(TypicalLEDStrip);
			break;
	}
}

// SetPixel()
//	
void SetPixel( int n, CRGB c) {
	for( unsigned int i = 0; i < Settings.nPixelsMulti; i++) {
		g_cPixels[n * Settings.nPixelsMulti + i] = c;
	}
}

void SetFontBrightness( int nBrightness) {
	//g_cFontRender = CRGB::White * ((float)nBrightness / 9.0) + .5;
	g_cFontRender.r = (uint8_t) 255.0 * ((float)nBrightness / 9.0) + .5;
	g_cFontRender.g = g_cFontRender.r;
	g_cFontRender.b = g_cFontRender.r;
}
void SetBackBrightness( int nBrightness) {
	g_nBackBright = (uint8_t) 255.0 * ((float)nBrightness / 9.0) + .5;
}


// ShowStrip()
//
inline void ShowStrip() {
	FastLED.show(); // display this frame
}

// RenderFrame
//
void RenderFrame() {

	static int nFrameDelay = 0;				// Skip n frames, this creates inter charactor spacing
	static int nFrameAnimator = 0;				// This just loops from 0-359 - used for animation
	
	bool bInhibit = 0;
	uint32_t buffer = 0;
	uint16_t i = 0;
	uint16_t iprime = 0;

	if ( bInhibit) {
		if( analogRead( 2) > 50) {
			bInhibit = false;
		}
		else {
			// clear the strip
			FastLED.clear();
			//for( i = 0; i < g_nFontPixels; i++) {
			//	SetPixel( i, CRGB::Black);
			//}
			return;
		}
	}

	// if at the beginning of a new message check
	// got NAV override?
	if( g_nEffectID == -1) {
		// NAV - show nav background only at full brightness
		for( i = 0; i < g_nFontPixels; i++) {
			iprime = ((Settings.nOrientationInverts & 2) >> 1) ? g_nFontPixels - i - 1 : i;
			SetPixel( i, Effect_Navigation( iprime, 255));
		}
		return;
	}
	else if (g_nEffectID == 3) {
		// call this effect once to render a full frame of effect
		Effect_PlasmaThrust( g_nBackBright);
	}

	// render background
	for (i = 0; i < g_nFontPixels; i++) {
		//iprime = (g_nOrientation ^ ((Settings.nOrientationInverts & 2) >> 1)) ? g_nFontPixels - i - 1 : i;
		iprime = ((Settings.nOrientationInverts & 2) >> 1) ? g_nFontPixels - i - 1 : i;
		switch (g_nEffectID) {
		case 0:
			SetPixel(i, CRGB::Black);
			break;
		case 1:
			SetPixel(i, Effect_Navigation(iprime, g_nBackBright));
			break;
		case 2:
			SetPixel(i, Effect_Rainbow(iprime, nFrameAnimator, g_nBackBright));
			break;
		default:
			break;
		}

		// full time nav
		if( ( i < 3 || i > 28) && Settings.nFullTimeNav) {
			SetPixel(i, Effect_Navigation(iprime, 255));
		}
	}
	// increment animator
	nFrameAnimator = (nFrameAnimator + g_nAnimSpeed) % 256;


	// in frame delay?
	if (nFrameDelay == 0) {
		// regular frame
		// read font data from program memory
		//buffer = pgm_read_dword(g_nColumnPtr);
		buffer = pgm_read_dword(g_nColumnPtr + g_nColumnNum);

		// copy column bits to strip
		for (i = 0; i < g_nFontPixels; i++) {
			// read a bit, if we are flipped then read in opposite order, respecting Settings.nOrientationInverts bit 2 toggle (x value from settings)
			iprime = (g_nOrientation ^ ((Settings.nOrientationInverts & 2) >> 1)) ? g_nFontPixels - i - 1 : i;
			if (bitRead(buffer, iprime)) {
				// there is font color here set to that
				SetPixel(i, g_cFontRender);
			}
		}

		// move to next column/charactor based on current orientation (0-normal, 1-flipped)
		if (g_nOrientation ^ (Settings.nOrientationInverts & 1)) {
			// flipped orientation

			// advance to previous column
			g_nColumnNum--;

			// are we past the beginning of the current char?
			if (g_nColumnNum <= 0) {

				// go to previous character in sMessage
				g_nCharNum--;
				nFrameDelay = Settings.nInterCharFrameGap;

				// past beginning of string?
				if (g_nCharNum < 0) {
					// wrap back to beginning
					g_nCharNum = strlen(Settings.sMessage[g_nCurrentMessage]) - 1;

					// this is for the wand, put a button to ground on A2 for inhibit switch
					// if A2 < 50 (noise level) - inhibit render
					if (analogRead(2) < 50) {
						bInhibit = true;
					}
				}

				// set index and pointer for next call to RenderFrame
				g_nCurrentChar = constrain(Settings.sMessage[g_nCurrentMessage][g_nCharNum] - g_nASCIIStart, 0, g_nASCIIEnd - g_nASCIIStart);
				g_nColumnPtr = CharacterMap[g_nCurrentChar];
				g_nCharWidth = pgm_read_dword(g_nColumnPtr);
				// set to end of current char
				g_nColumnNum = g_nCharWidth;
			}
		}
		else {
			// normal orientation

			// advance to next column
			g_nColumnNum++;

			// are we at the end of the current char?
			if (g_nColumnNum > (int) g_nCharWidth) {

				// go to next character in sMessage
				g_nCharNum++;
				nFrameDelay = Settings.nInterCharFrameGap;

				// end of string?
				if ((unsigned int)g_nCharNum >= sizeof(Settings.sMessage[g_nCurrentMessage]) - 1 || Settings.sMessage[g_nCurrentMessage][g_nCharNum] == '\0') {
					// wrap back to beginning
					g_nCharNum = 0;

					// this is for the wand, put a button to ground on A2 for inhibit switch
					// if A2 < 50 (noise level) - inhibit render
					if (analogRead(2) < 50) {
						bInhibit = true;
					}

				}

				// set index and pointer for next call to RenderFrame
				g_nCurrentChar = constrain(Settings.sMessage[g_nCurrentMessage][g_nCharNum] - g_nASCIIStart, 0, g_nASCIIEnd - g_nASCIIStart);
				g_nColumnPtr = CharacterMap[g_nCurrentChar];
				g_nCharWidth = pgm_read_dword(g_nColumnPtr);
				// set to beginning of current char
				g_nColumnNum = 1;
			}
		}
	}
	else {
		nFrameDelay--;
	} // frame delay else

}


//	Effect_Rainbow
//
//		int i				- pixel num
//		int nDegrees,		- 0 - 255 - call with incrementing number to animate
//		int coef			- brightness
//
inline CRGB Effect_Rainbow( int i, int nDegrees, int bright) {
	return ColorFromPalette( RainbowColors_p, i * (256 / g_nFontPixels) + nDegrees, bright);
}


//	Effect_Navigation
//
//		int i				- pixel num
//		int bright			- brightness
//
inline CRGB Effect_Navigation( int i, uint8_t bright) {
	return (i < (g_nFontPixels / 2)) ? (CRGB){bright,0,0} : (CRGB){0,bright,0};
	//return (i < (g_nFontPixels / 2)) ? CRGB::Red : CRGB::Green;
}


//	Effect_PlasmaThrust
//
//
void Effect_PlasmaThrust(int bright)
{
	int nEffectWidth = g_nFontPixels * Settings.nPixelsMulti;
	// Array of temperature readings at each simulation cell
	static byte heat[g_nStripPixels] = { 0 };
	int nCoolingPrime = (COOLING * 10) / nEffectWidth;
	CRGBPalette16 cPallette;

	switch( g_nEffectPalleteID) {
		case 1: cPallette = HeatColors_p; break;
		case 2: cPallette = CRGBPalette16(CRGB::Black, CRGB::Green, CRGB::Blue, CRGB::Violet); break;
		case 3: cPallette = CRGBPalette16(CRGB::Black, CRGB::Green, CRGB::Aqua, CRGB::Violet); break;
		default:
		case 4: cPallette = CRGBPalette16(CRGB::Black, CRGB::Gold, CRGB::Red, CRGB::DarkBlue); break;
		case 5: cPallette = CRGBPalette16(CRGB::Black, CRGB::Blue, CRGB::Yellow, CRGB::White); break;
		case 6: cPallette = CRGBPalette16(CRGB::Black, CRGB::Blue, CRGB::Aqua, CRGB::White); break;
	}

	// Constant heat source at center
	heat[0] = qadd8(heat[0], random8(4));
	heat[1] = qadd8(heat[1], random8(4));

	// Cool down every cell a little
	for (int i = 0; i < nEffectWidth; i++) {
		heat[i] = qsub8(heat[i], random8(nCoolingPrime + 2));
		//heat[i] = qsub8(heat[i], random8( COOLING) + 2);
	}

	// Heat from each cell drifts 'up' and diffuses a little
	for (int k = nEffectWidth - 1; k >= 2; k--) {
		heat[k] = (heat[k - 1] + heat[k - 2] + heat[k - 2]) / 3;
	}

	// Randomly ignite new 'sparks' of heat near the bottom
	if (random8() < SPARKING) {
		// doing this so it has a assymetrical effect across the two sides in missle mode
		for (int j = random8(2); j <= 3; j += 2) {
			heat[j] = qadd8(heat[j], random8(100, 200));
		}
	}

	// Render heat cells with pallette colors
	//SetPixel(nPixel, ColorFromPalette(HeatColors_p, heat[nPixel]));

	for (int j = 0; j < nEffectWidth / 2; j++) {
		g_cPixels[nEffectWidth / 2 + j] = ColorFromPalette(cPallette, scale8(heat[j * 2], 240), g_nBackBright);
		g_cPixels[nEffectWidth / 2 - j - 1] = ColorFromPalette(cPallette, scale8(heat[(j * 2) + 1], 240), g_nBackBright);
		//leds[NUM_LEDS / 2 + j] = HeatColor(heat[j*2]);
		//leds[NUM_LEDS / 2 - j - 1] = HeatColor(heat[(j*2)+1]);
	}

	if (SPARKING > SPARKING_MAX * SPARKING_THRESH) {
		// Glitter sparkles
		for (int j = 0; j < nEffectWidth; j++) {
			if (random8() < 7 &&				// Master attenuator
				random8() < SPARKING) 			// SPARKING attenuator
				//g_cPixels[j] = ColorFromPalette(cPallette, 255, g_nBackBright);
				g_cPixels[j] = CRGB::White;
		}
	}
	
}


// setup()
//
void setup() {

	// open serial ports
	Serial.begin( USB_BAUD_RATE);
	BTSerial.begin( BT_BAUD_RATE);

	//load settings
	LoadSettings();

	// setup pins
	if( Settings.nFrameRatePin > 0) pinMode(Settings.nFrameRatePin, INPUT);
	if( Settings.nMessageSelectPin > 0) pinMode(Settings.nMessageSelectPin, INPUT);
	if( Settings.nOrientationPin > 0) pinMode(Settings.nOrientationPin, INPUT);

	// Start up the LED strip.
	InitStrip();

	// set initial PWM values - call 3 times since I multiplex the inputs to keep the speed up
	UpdateInputs(); UpdateInputs(); UpdateInputs();

	// setup first frame
	ResetMessage();

	// pre-render frame so the the first time loop is called there is something to show
	RenderFrame();

	//show masthead and prompt
	SerialPrintln( BOTH_PORTS);
	SerialPrint( F("Welcome to Firefly POV - By Buck McGibbony and Paul Drucker - Version "), BOTH_PORTS); SerialPrintln( VERSION, BOTH_PORTS);
	SerialPrintln( BOTH_PORTS);
	SerialPrint( F("Firefly POV>"), BOTH_PORTS);
}


// loop
//
void loop() {

	// this being the highest frequency loop available we will drive our various tasks from here
	// each task has its own frame rate.

	// record entrance time
	unsigned long ulTimeNow = millis();

	// FrameRate heartbeat
	if ( ulTimeNow >= g_ulNextFrameTime) {
		// calc next frame (do this first so it is lined up better)
		g_ulNextFrameTime = ulTimeNow + long(( 1000.0 / float(g_nFrameRate)));

		// we blit the frame buffer out to the strip first so that the appearance of changes to the strip are consistant thru time
		// this way the time to process the next frame is not seen since it happens between the blit and the next frame
		ShowStrip();
		digitalWrite(LED_BUILTIN, 0);
		RenderFrame();

		// detect time frame overflow
		if ( millis() >= g_ulNextFrameTime) {
			// we are going too fast, just send out a blank so that the user can see that we hit the wall
			//SerialPrint(F("!"), USB_PORT);
			//nFrameDelay = g_nFrameRate;
			digitalWrite(LED_BUILTIN, 1);
			//digitalWrite(LED_BUILTIN, !digitalRead(LED_BUILTIN));
		}
	}

	// PWMSampleRate heartbeat
	// wait for scheduled check and its a frame delay, has less impact on speed that way
	if ( (ulTimeNow >= g_ulNextPWMSampleTime)) {
		g_ulNextPWMSampleTime = ulTimeNow + long(( 1000.0 / float(g_nSampleRate)));
//#pragma message "Don't forget to turn on UpdateInputs() when all the crapola is fixed"
		UpdateInputs();
	}


	//service comm ports
	while( Serial.available()) SerialEvent( USB_PORT);
	while( BTSerial.available()) SerialEvent( BT_PORT);
}


// ResetMessage
//
void ResetMessage() {

	int n;
	int nCharNum = 0;

	// set index and char pointer to beginning
	g_nCharNum = 0;
	g_nCurrentChar = constrain(Settings.sMessage[g_nCurrentMessage][g_nCharNum] - g_nASCIIStart, 0, g_nASCIIEnd - g_nASCIIStart);
	g_nColumnPtr = CharacterMap[g_nCurrentChar];
	g_nCharWidth = pgm_read_dword(g_nColumnPtr);
	g_nColumnNum = 1;


	// set format defaults
	SetBackBrightness( Settings.nBackBrightness);
	SetFontBrightness( Settings.nFontBrightness);

	g_nEffectID = 0;
	g_nEffectPalleteID = 0;

	// check message string for \NAV code
	if( strcasecmp( Settings.sMessage[g_nCurrentMessage], "\\NAV") == 0) {
		g_nEffectID = -1;
	}
	else {
		// read format string
		n = strlen( Settings.sFormat[g_nCurrentMessage]);
		for( nCharNum = 0; (size_t)nCharNum < strlen( Settings.sFormat[g_nCurrentMessage]); nCharNum++) {
			if( Settings.sFormat[g_nCurrentMessage][nCharNum] == '\\') {
				char nChar = Settings.sFormat[g_nCurrentMessage][nCharNum+1];
				// \Bn
				if( nChar == 'b' || nChar == 'B') {
					n = constrain( Settings.sFormat[g_nCurrentMessage][nCharNum+2] - '0',0,9);
					SetFontBrightness( n);
					nCharNum += 2;
				}

				// \Nn
				else if( nChar == 'n' || nChar == 'N') {
					n = constrain( Settings.sFormat[g_nCurrentMessage][nCharNum+2] - '0',0,9);
					SetBackBrightness( n);
					nCharNum += 2;
				}

				// \En
				else if( nChar == 'e' || nChar == 'E') {
					n = constrain( Settings.sFormat[g_nCurrentMessage][nCharNum+2] - '0',0,9);
					g_nEffectID = n;
					nCharNum += 2;
				}

				// \Pn
				else if (nChar == 'p' || nChar == 'P') {
					n = constrain(Settings.sFormat[g_nCurrentMessage][nCharNum + 2] - '0', 0, 9);
					g_nEffectPalleteID = n;
					nCharNum += 2;
				}
			}
		}
	}
}


// SerialEvent()
//
void SerialEvent( int nPort) {
	char sInputChar = 0;   // for incoming serial data
	int nPortIndex = 0;

	// read the incoming char
	//  sBuffer[Serial.readBytes(sBuffer, Serial.available())] = 0;
	switch( nPort) {
	case USB_PORT:
		sInputChar = Serial.read();
		nPortIndex = 0;
		break;

	case BT_PORT:
		sInputChar = BTSerial.read();
		nPortIndex = 1;
		break;
	}

	switch( sInputChar) {
		case '\r':  // Carriage return /Enter 0x0d
			if( g_nCommandLength[nPortIndex] > 0) {
				SerialPrintln( nPort);
				ProcessCommand( g_sCommandBuffer[nPortIndex], nPort);
				switch( nPort) {
				case USB_PORT:
					Serial.flush();
					break;

				case BT_PORT:
					BTSerial.flush();
					break;
				}
				g_nCommandLength[nPortIndex] = 0;
			}

			//show prompt
			SerialPrintln( nPort);
			SerialPrint( F("Firefly POV>"), nPort);
			break;

		case 127: // Backspace
			if( g_nCommandLength[nPortIndex] > 0) {
				SerialPrint( sInputChar, nPort);
				//SerialPrint( " ", nPort); SerialPrint( sInputChar, nPort);
				g_sCommandBuffer[nPortIndex][--g_nCommandLength[nPortIndex]] = '\0';
			}
			break;

		default: 
			// if sInputChar is a visible (non-escape code) character then we append it to our command line buffer
			if( (int) sInputChar > 31 && (int) sInputChar < 127) {
				if( g_nCommandLength[nPortIndex] < sizeof( g_sCommandBuffer[nPortIndex])) {
					// echo char
					if( nPort & USB_PORT) SerialPrint( sInputChar, nPort);
					g_sCommandBuffer[nPortIndex][g_nCommandLength[nPortIndex]] = sInputChar;
					g_sCommandBuffer[nPortIndex][++g_nCommandLength[nPortIndex]] = '\0';
				}
			}
			break;
	}
}

// ProcessCommand
//
void ProcessCommand( char *sCommand, int nPort) {

	int n;
	int n1;

	switch( sCommand[0]) {
		case 'A':
		case 'a':
			// message command
			n = constrain( sCommand[1] - '1', 0, 8);  // convert the ascii number to 0-4 for using as index
			if( sCommand[2] == '=') {
				// set message format n to abc
				if( strlen( &sCommand[3]) > sizeof( Settings.sFormat[n]) - 1) {
					SerialPrint( F("Format too long, max length is "), nPort); SerialPrint( sizeof( Settings.sFormat[n]) - 1, nPort); SerialPrintln( F(" chars."), nPort);
				}
				else {
					strcpy( Settings.sFormat[n], &sCommand[3]);
					SerialPrint( "A", nPort); SerialPrint( n+1, nPort); SerialPrint( "=\"", nPort); SerialPrint( Settings.sFormat[n], nPort); SerialPrintln( "\"", nPort); 
				}
			}
			ResetMessage();
			break;

		case 'B':
		case 'b':
			// Set font brightness
			n = constrain(sCommand[1] - '0',0,9);
			Settings.nFontBrightness = n;
			SetFontBrightness( Settings.nFontBrightness);

			SerialPrint( F("Font brightness set to "), nPort); SerialPrintln( Settings.nFontBrightness, nPort); 
			break;

		case 'c':
		case 'C':
			CalibrateInputs( nPort);
			break;

		case 'd':
		case 'D':
			// Load Defaults
			LoadDefaults();
			SerialPrintln( F("Loaded default settings."), nPort);
			ResetMessage();
			break;

		case 'f':
		case 'F':
			n = constrain(atoi( &sCommand[3]), 1, 420);
			switch( sCommand[1]) {
				case 'n':
				case 'N':
					Settings.nMinFrameRate = n;
					SerialPrint( F("Min frame rate set to "), nPort); SerialPrintln( n, nPort); 
					break;

				case 'x':
				case 'X':
					Settings.nMaxFrameRate = n;
					SerialPrint( F("Max frame rate set to "), nPort); SerialPrintln( n, nPort); 
					g_nFrameRate = Settings.nMaxFrameRate;
					break;
			}
			// make sure frame rate is inside new constraints
			g_nFrameRate = constrain( g_nFrameRate, Settings.nMinFrameRate, Settings.nMaxFrameRate);
			break;

		case 'G':
		case 'g':
			// Set character frame gap (space between characters)
			n = constrain(sCommand[1] - '0',1,9);
			Settings.nInterCharFrameGap = n;
			SerialPrint( F("Character frame gap set to "), nPort); SerialPrintln( n, nPort); 
			break;

		case 'i':
		case 'I':
			// Set orientation inverts
			n = constrain(sCommand[1] - '0',0,1);
			n1 = constrain(sCommand[2] - '0',0,1);
			Settings.nOrientationInverts = n * 2 + n1;
			g_nLastPWMOrientationValue = 0;  // force recalc of orientation variable
			SerialPrint( F("Inverts set to: "), nPort); SerialPrint( n, nPort); SerialPrintln( n1, nPort); 
			ResetMessage();
			break;

		case 'l':
		case 'L':
			SerialPrintln( F("Current Settings:"), nPort);
			SerialPrintln( nPort);
			SerialPrint( F("Font Brightness = "), nPort); SerialPrintln( Settings.nFontBrightness, nPort);
			SerialPrint( F("Back Brightness = "), nPort); SerialPrintln( Settings.nBackBrightness, nPort);
			SerialPrint( F("Min Frame Rate  = "), nPort); SerialPrintln( Settings.nMinFrameRate, nPort);
			SerialPrint( F("Max Frame Rate  = "), nPort); SerialPrintln( Settings.nMaxFrameRate, nPort);
			SerialPrint( F("Character Gap   = "), nPort); SerialPrintln( Settings.nInterCharFrameGap, nPort);
			SerialPrintln( nPort);
			
			SerialPrint( F("Frame Rate Pin       = "), nPort); 
			if( Settings.nFrameRatePin > 0) {
				SerialPrint( F("D"), nPort);
				SerialPrint( Settings.nFrameRatePin, nPort);
				SerialPrint( F(" ["), nPort); SerialPrint( Calibrations.nFrameRate_LowVal, nPort); SerialPrint( "-", nPort); SerialPrint( Calibrations.nFrameRate_HighVal, nPort); SerialPrintln( "]", nPort); }
			else {
				SerialPrintln( F("disabled"), nPort);
			}

			SerialPrint( F("Message Select Pin   = "), nPort);
			if( Settings.nMessageSelectPin > 0) {
				SerialPrint( F("D"), nPort);
				SerialPrint( Settings.nMessageSelectPin, nPort);
			}
			else {
				SerialPrint( F("A"), nPort);
				SerialPrint( abs(Settings.nMessageSelectPin), nPort);
			}
			SerialPrint( F(" ["), nPort); SerialPrint( Calibrations.nMessageSelect_LowVal, nPort); SerialPrint( "-", nPort); SerialPrint( Calibrations.nMessageSelect_HighVal, nPort); SerialPrintln( "]", nPort);

			SerialPrint( F("Orientation Pin      = "), nPort);
			if( Settings.nOrientationPin > 0) {
				SerialPrint( F("D"), nPort);
				SerialPrint( Settings.nOrientationPin, nPort);
				SerialPrint( F(" ["), nPort); SerialPrint( Calibrations.nOrientation_LowVal, nPort); SerialPrint( "-", nPort); SerialPrint( Calibrations.nOrientation_HighVal, nPort); SerialPrintln( "]", nPort); }
			else {
				SerialPrintln( F("disabled"), nPort);
			}
			
			SerialPrint( F("Render Inhibit       = A2"), nPort); SerialPrintln( " (ground = pause)", nPort);
			SerialPrint( F("Orientation Deadzone = "), nPort); SerialPrint( Settings.nOrientationDeadZone, nPort); SerialPrintln( "%", nPort);
			
			n = (Settings.nOrientationInverts & 2) >> 1;
			n1 = Settings.nOrientationInverts & 1;
			SerialPrint( F("Orientation Inverts  = "), nPort); SerialPrint( n, nPort); SerialPrint( n1, nPort); SerialPrint( " (Current Orientation: ", nPort); SerialPrint( g_nOrientation, nPort); SerialPrintln( ")", nPort);

			SerialPrint( F("Strip Type           = "), nPort); SerialPrint( Settings.nStripType, nPort); 
			switch( Settings.nStripType) {
				case aWS2812B:
					SerialPrintln( F(" (WS2812B)"), nPort);
					break;
				case aLPD8806:
					SerialPrintln( F(" (LPD8806)"), nPort);
					break;
			}
			
			SerialPrint( F("Pixel Multiplier     = "), nPort); SerialPrintln( Settings.nPixelsMulti, nPort); 
			SerialPrint( F("Full Time Nav        = "), nPort); SerialPrintln(Settings.nFullTimeNav, nPort);

			SerialPrintln( nPort);
			SerialPrint( F("Active Messages = "), nPort); SerialPrintln( Settings.nNumMessages, nPort);
			for( int i = 0; i < Settings.nNumMessages; i++) {
				if( i == g_nCurrentMessage) SerialPrint( F("*M"), nPort); else SerialPrint( " M", nPort);
				SerialPrint( i+1, nPort); SerialPrint( "=\"", nPort); SerialPrint( Settings.sMessage[i], nPort); SerialPrint( "\"", nPort);

				int iMax=sizeof( Settings.sMessage[i])-strlen(Settings.sMessage[i]);
				for(int i1=0; i1<iMax; i1++) SerialPrint( " ", nPort);
				SerialPrint( F(" >> "), nPort); SerialPrint( Settings.sFormat[i], nPort); 

				SerialPrintln( nPort);
			}
			//SerialPrintln( nPort);
			SerialPrint( F("Current Frame Rate: "), nPort); SerialPrint( g_nFrameRate, nPort); SerialPrintln( F(" fps"), nPort);
			//SerialPrint(F("S "), nPort); SerialPrintln(SPARKING, nPort);
			//SerialPrint(F("C "), nPort); SerialPrintln(COOLING, nPort);
			break;

		case 'M':
		case 'm':
			if( sCommand[1] == 'A' || sCommand[1] == 'a') {
				// set message actives count
				Settings.nNumMessages = constrain( sCommand[3] - '0', 1, 9);
				SerialPrint( F("Active messages set to "), nPort); SerialPrintln( Settings.nNumMessages, nPort);
			}
			else {
				// message command
				n = constrain( sCommand[1] - '1', 0, 8);  // convert the ascii number to 0-4 for using as index
				// are we setting a message or selecting?  look for that '=' sign at position 3
				if( sCommand[2] == '=') {
					// set message n to abc
					if(strlen(&sCommand[3]) > sizeof( Settings.sMessage[n]) - 1) {
						SerialPrint( F("Message too long, max length is "), nPort); SerialPrint( sizeof( Settings.sMessage[n]) - 1, nPort); SerialPrintln( F(" chars."), nPort);
					}
					else {
						strcpy( Settings.sMessage[n], &sCommand[3]);
						SerialPrint( "M", nPort); SerialPrint( n+1, nPort); SerialPrint( "=\"", nPort); SerialPrint( Settings.sMessage[n], nPort); SerialPrintln( "\"", nPort); 
					}
				}
				else {
					// selecting message n
					g_nCurrentMessage = n;
					SerialPrint( F("Message "), nPort); SerialPrint( n+1, nPort); SerialPrintln( F(" selected."), nPort);
				}
			}
			ResetMessage();
			break;

		case 'N':
		case 'n':
			// Set Nav brightness
			Settings.nBackBrightness = constrain(sCommand[1] - '0',0,9);
			SetBackBrightness( Settings.nBackBrightness);
			SerialPrint( F("BackBrightness set to "), nPort); SerialPrintln( Settings.nBackBrightness, nPort); 
			break;

		case 'p':
		case 'P':
			n = constrain(atoi( &sCommand[3]), -15, 13);
			if( n == 1) {
				SerialPrintln( F("pin 1 used by SPI."), nPort);
			}
			else {
				switch( sCommand[1]) {
					case 'f':
					case 'F':
						Settings.nFrameRatePin = n;
						SerialPrint( F("FrameRate Pin set to "), nPort); SerialPrintln( n, nPort); 
						if( Settings.nFrameRatePin > 0) pinMode(Settings.nFrameRatePin, INPUT);
						break;
					case 'm':
					case 'M':
						Settings.nMessageSelectPin = n;
						SerialPrint( F("MessageSelect Pin set to "), nPort); SerialPrintln( n, nPort); 
						if( Settings.nMessageSelectPin > 0) {
							pinMode(Settings.nMessageSelectPin, INPUT);
							Calibrations.nMessageSelect_LowVal = 1000;
							Calibrations.nMessageSelect_HighVal = 2000;
						}
						else {
							Calibrations.nMessageSelect_LowVal = 0;
							Calibrations.nMessageSelect_HighVal = 1024;
						}
						SaveCalibrations();
						break;
					case 'o':
					case 'O':
						Settings.nOrientationPin = n;
						SerialPrint( F("Orientation Pin set to "), nPort); SerialPrintln( n, nPort);
						if( Settings.nOrientationPin > 0) pinMode(Settings.nOrientationPin, INPUT);
						break;
				}
			}
			break;

		case 'r':
		case 'R':
			LoadSettings();
			SerialPrintln( F("Settings reloaded."), nPort);
			ResetMessage();
			break;

		case 's':
		case 'S':
			SaveSettings();
			SerialPrintln( F("Settings saved."), nPort);
			break;

		case 't':
		case 'T':
			switch( sCommand[1]) {
				case 's':
				case 'S':
					// set strip type
					// aWS2812B = 1,
					// aLPD8806 = 2,
					Settings.nStripType = (STRIP_TYPE) constrain( sCommand[2]-'0', aWS2812B, aLPD8806);
					InitStrip();

					SerialPrint( F("Strip Type set to "), nPort); SerialPrintln( Settings.nStripType, nPort);
					break;

				case 'x':
				case 'X':
					// clear the strip
					for( n = 0; n < g_nFontPixels; n++) {
						SetPixel( n, CRGB::Black);
					}
					ShowStrip();

					// set new multiplier
					Settings.nPixelsMulti = constrain( sCommand[2]-'0', 1, 4);
					//InitStrip();

					SerialPrint( F("Pixel Multi set to "), nPort); SerialPrintln( Settings.nPixelsMulti , nPort);
					break;
			}
			break;

		case 'V':
		case 'v':
			// Set full time nav
			Settings.nFullTimeNav = constrain(sCommand[1] - '0', 0, 1);
			SerialPrint(F("Full time nav set to "), nPort); SerialPrintln(Settings.nFullTimeNav, nPort);
			break;

		case 'z':
		case 'Z':
			n = constrain(atoi( &sCommand[2]), 0, 10);
			Settings.nOrientationDeadZone = n;
			SerialPrint( F("Orientation deadzone set to "), nPort); SerialPrint( n, nPort); SerialPrintln( F(" percent."), nPort);
			break;

			// make sure frame rate is inside new constraints
			g_nFrameRate = constrain( g_nFrameRate, Settings.nMinFrameRate, Settings.nMaxFrameRate);
			break;

		case 'h':
		case '?':
			SerialPrint( F("FireFly POV - By Buck McGibbony and Paul Drucker - Version "), nPort); SerialPrintln( VERSION, nPort);
			SerialPrintln( nPort);
			SerialPrintln( F("   Bx     - Set font brightness to x (0-9)"), nPort);
			SerialPrintln( F("   Nx     - Set background brightness to x (0-9)"), nPort);
			SerialPrintln( F("   Gx     - Set character frame gap (1-9)"), nPort);
			SerialPrintln( F("   FN=x   - Set frame rate min to x (1-320 fps)"), nPort);
			SerialPrintln( F("   FX=x   - Set frame rate max to x (1-320 fps)"), nPort);
			SerialPrintln( F("   Mx=abc - Set message x (1-9) to abc, no quotes"), nPort);
			SerialPrintln( F("            \\NAV - show nav lights at full bright"), nPort);
			SerialPrintln( F("   Ax=abc - Set format x (1-9) abc, no quotes"), nPort);
			SerialPrintln( F("            \\Bn - Font brightness"), nPort);
			SerialPrintln( F("            \\Nn - Bkgrnd brightness"), nPort);
			SerialPrintln( F("            \\En - Bkgrnd Effect - 0=Black, 1=Nav, 2=Rainbow, 3=Thrust"), nPort);
			SerialPrintln( F("            \\Pn - Effect Pallette - 0=Default, 1-6"), nPort);
			SerialPrintln( F("   Mx     - Select message x (1-9)"), nPort);
			SerialPrintln( F("   MA=x   - Set number of messages to be active to x (1-9)"), nPort);
			SerialPrintln( F("   PF=x   - Set frame rate pin to x (0 for none)"), nPort);
			SerialPrintln( F("   PM=x   - Set message select pin to x (0 - -5 for A0 - A5)"), nPort);
			SerialPrintln( F("   PO=x   - Set orientation pin to x (0 for none)"), nPort);
			SerialPrintln( F("   Z=x    - Set orientation deadzone to x (% full range)"), nPort);
			SerialPrintln( F("   Ixy    - Set paint inverts x = 0(L->R) or 1(R->L)"), nPort);
			SerialPrintln( F("            and strip orientation y = 0(up) or 1(down)"), nPort);
			SerialPrintln( F("   TXx    - Set Pixel Multiplier to x (1-4)"), nPort);
			SerialPrintln( F("   TSx    - Set Strip Type to x (1=WS2812B, 2=LPD8806)"), nPort);
			SerialPrintln( F("   C      - Start calibration sequence"), nPort);
			SerialPrintln( F("   L      - List settings"), nPort);
			SerialPrintln( F("   D      - Load default settings"), nPort);
			SerialPrintln( F("   R      - Reload settings from EEPROM"), nPort);
			SerialPrintln( F("   S      - Save settings to EEPROM"), nPort);
		break;
	
		default:
			SerialPrintln( F("Command unrecognized.  Type '?' or 'h' for help."), nPort);
			break;
	}

}


//  UpdateInputs()
//
void UpdateInputs() {
	
	int n;
	int nDeltaC;
	unsigned long n_Raw;

	switch( g_nCurrentInputCheck) {
		case 0:
			// frame rate from PWM input?
			if( Settings.nFrameRatePin > 0) {
				n_Raw = pulseIn( Settings.nFrameRatePin, HIGH, PWM_TIMEOUT); // no constrain here
				if( n_Raw == 0) n_Raw = Calibrations.nFrameRate_HighVal;

				if( abs(g_nLastPWMFrameRateValue - n_Raw) > PWM_NOISEFLOOR) {
					g_nLastPWMFrameRateValue = n_Raw;
					g_nFrameRate = constrain( map( n_Raw, Calibrations.nFrameRate_LowVal, Calibrations.nFrameRate_HighVal, Settings.nMinFrameRate, Settings.nMaxFrameRate+1), Settings.nMinFrameRate, Settings.nMaxFrameRate);

					// calculate plasma settings
					if (g_nEffectID == 3) {
						//SPARKING = SPARKING_MIN;
						//COOLING = COOLING_MAX;
						SPARKING = map(n_Raw, Calibrations.nFrameRate_LowVal, Calibrations.nFrameRate_HighVal, SPARKING_MIN, SPARKING_MAX);
						COOLING = map(n_Raw, Calibrations.nFrameRate_LowVal, Calibrations.nFrameRate_HighVal, COOLING_MAX, COOLING_MIN);
					}
				}

			}
			else {
				g_nFrameRate = Settings.nMaxFrameRate; // no PWM sensing just use Settings.nMaxFrameRate
			}
			
			
			g_nCurrentInputCheck = 1;
			break;

		case 1:
			// Pattern select
			if( Settings.nMessageSelectPin > 0) {
				n_Raw = pulseIn( Settings.nMessageSelectPin, HIGH, PWM_TIMEOUT); // get PWM value
			}
			else {
				n_Raw = analogRead( abs(Settings.nMessageSelectPin) );  // get analog value from pin Ax
			}
			if( n_Raw == 0) n_Raw = Calibrations.nMessageSelect_HighVal;

			if( abs(g_nLastMessageSelectValue - n_Raw) > PWM_NOISEFLOOR) { // this filters the noise
				g_nLastMessageSelectValue = n_Raw;
				n = constrain( map( n_Raw, Calibrations.nMessageSelect_LowVal, Calibrations.nMessageSelect_HighVal, 0, Settings.nNumMessages ), 0, Settings.nNumMessages-1);
				if( g_nCurrentMessage != n) {
					g_nCurrentMessage = n;
					ResetMessage();
				}
			}
			g_nCurrentInputCheck = 2;
			break;

		case 2:
			// Orientation control from PWM input
			if( Settings.nOrientationPin > 0) {
				n_Raw = pulseIn( Settings.nOrientationPin, HIGH, PWM_TIMEOUT); // no constrain here
				if( n_Raw == 0) n_Raw = Calibrations.nOrientation_HighVal;

				if( abs(g_nLastPWMOrientationValue - n_Raw) > PWM_NOISEFLOOR) {
					g_nLastPWMOrientationValue = n_Raw;
					nDeltaC = map( n_Raw, Calibrations.nOrientation_LowVal, Calibrations.nOrientation_HighVal, 0, 101) - Calibrations.nOrientation_Normal; // Use normal as dead center
					if( abs( nDeltaC) > Settings.nOrientationDeadZone) {
						// set g_nOrientation based on whether DeltaC is positive or negative
						g_nOrientation = nDeltaC < 0 ? LOW : HIGH;
					}
				}
			}
			g_nCurrentInputCheck = 0;
			break;

	}
}

// Calibrate PWM inputs
//
void CalibrateInputs( int nPort) {

	unsigned long n_Raw;
	unsigned long ulTimeNow;
	unsigned long n_LowVal;
	unsigned long n_HighVal;
	const int nTimeout = 7000; // Calibration timeout in millis

//	void *SettingsBlockStart = &Settings;

	SerialPrint( F("PWM input calibration initiated.  Each step will last "), nPort); SerialPrint( nTimeout / 1000, nPort); SerialPrintln( F(" seconds."), nPort);
	
	if( Settings.nFrameRatePin > 0) {
		SerialPrintln( nPort);
		SerialPrint( F(">> Please cycle the FRAME RATE input on pin "), nPort); SerialPrintln( Settings.nFrameRatePin, nPort);

		n_LowVal = 1500;
		n_HighVal = 1500;
		ulTimeNow = millis(); // record entrance time
		do {
			n_Raw = pulseIn( Settings.nFrameRatePin, HIGH, PWM_TIMEOUT);
			if( n_Raw < n_LowVal) n_LowVal = n_Raw;
			else if( n_Raw > n_HighVal) n_HighVal = n_Raw;
		} while( millis() - ulTimeNow < nTimeout);

		// did we get some useful data?
		if( n_LowVal == 1500 || n_HighVal == 1500) {
			SerialPrint( F("TIMEOUT: no PWM input on pin "), nPort); SerialPrintln( Settings.nFrameRatePin, nPort);
		}
		// yes we did
		else {
			Calibrations.nFrameRate_LowVal = n_LowVal;
			Calibrations.nFrameRate_HighVal = n_HighVal;
			SerialPrint( F("Frame Rate PWM extents ["), nPort); SerialPrint( Calibrations.nFrameRate_LowVal, nPort); SerialPrint( "-", nPort); SerialPrint( Calibrations.nFrameRate_HighVal, nPort); SerialPrintln( "]", nPort); 
		}
	}

	SerialPrintln( nPort);
	SerialPrint( F(">> Please cycle MESSAGE SELECT on pin "), nPort); SerialPrintln( Settings.nMessageSelectPin, nPort);

	ulTimeNow = millis(); // record entrance time

	if( Settings.nMessageSelectPin > 0) {
		n_LowVal = 1500;
		n_HighVal = 1500;
		do {
			n_Raw = pulseIn( Settings.nMessageSelectPin, HIGH, PWM_TIMEOUT);
			if( n_Raw < n_LowVal) n_LowVal = n_Raw;
			else if( n_Raw > n_HighVal) n_HighVal = n_Raw;
		} while( millis() - ulTimeNow < nTimeout);
	}
	else {
		n_LowVal = 512;
		n_HighVal = 512;
		do {
			n_Raw = analogRead( abs(Settings.nMessageSelectPin));
			if( n_Raw < n_LowVal) n_LowVal = n_Raw;
			else if( n_Raw > n_HighVal) n_HighVal = n_Raw;
		} while( millis() - ulTimeNow < nTimeout);
	}

	// did we get some useful data?
	if( n_LowVal == 1500 || n_HighVal == 1500 || n_LowVal == 512 || n_HighVal == 512) {
		SerialPrint( F("TIMEOUT: no input on pin "), nPort); SerialPrintln( Settings.nMessageSelectPin, nPort);
	}
	// yes we did
	else {
		Calibrations.nMessageSelect_LowVal = n_LowVal;
		Calibrations.nMessageSelect_HighVal = n_HighVal;
		SerialPrint( F("Message Select extents were ["), nPort); SerialPrint( Calibrations.nMessageSelect_LowVal, nPort); SerialPrint( "-", nPort); SerialPrint( Calibrations.nMessageSelect_HighVal, nPort); SerialPrintln( "]", nPort); 
	}

	if( Settings.nOrientationPin > 0) {
		SerialPrintln( nPort);
		SerialPrint( F(">> Please cycle ORIENTATION on pin "), nPort); SerialPrintln( Settings.nOrientationPin, nPort);

		n_LowVal = 1500;
		n_HighVal = 1500;
		ulTimeNow = millis(); // record entrance time
		do {
			n_Raw = pulseIn( Settings.nOrientationPin, HIGH, PWM_TIMEOUT);
			if( n_Raw < n_LowVal) n_LowVal = n_Raw;
			else if( n_Raw > n_HighVal) n_HighVal = n_Raw;
		} while( millis() - ulTimeNow < nTimeout);

		// did we get some useful data?
		if( n_LowVal == 1500 || n_HighVal == 1500) {
			SerialPrint( F("TIMEOUT: no PWM input on pin "), nPort); SerialPrintln( Settings.nOrientationPin, nPort);
		}
		// yes we did
		else {
			Calibrations.nOrientation_LowVal = n_LowVal;
			Calibrations.nOrientation_HighVal = n_HighVal;

			// sample current position to get the normal
			SerialPrintln( F("Setting ORIENTATION normal..."), nPort);
			ulTimeNow = millis(); // record entrance time
			do {
				n_Raw = pulseIn( Settings.nOrientationPin, HIGH, PWM_TIMEOUT);
				if( n_Raw < n_LowVal) n_LowVal = n_Raw;
				else if( n_Raw > n_HighVal) n_HighVal = n_Raw;
			} while( millis() - ulTimeNow < nTimeout / 2);
			
			//get normal value
			n_Raw = pulseIn( Settings.nOrientationPin, HIGH, PWM_TIMEOUT);
			// map the PWM normal value now so we don't have to remap it every time we use it later on
			Calibrations.nOrientation_Normal  = map( n_Raw, Calibrations.nOrientation_LowVal, Calibrations.nOrientation_HighVal, 0, 101);
			SerialPrint( F("Orientation PWM extents ["), nPort); SerialPrint( Calibrations.nOrientation_LowVal, nPort); SerialPrint( "-", nPort); SerialPrint( Calibrations.nOrientation_HighVal, nPort); SerialPrint( ":", nPort); SerialPrint( n_Raw , nPort); SerialPrintln( "]", nPort); 
		}
	}

	// if we made it this far then it must have all worked out
	// lets save the calibration data to EEPROM
	SerialPrintln( F( "Saving calibration data."), nPort);
	SaveCalibrations();
}



// SerialPrint() + overloads
void SerialPrint( const __FlashStringHelper* buffer, int nPort) {
	if( nPort & USB_PORT) Serial.print( buffer);
	if( nPort & BT_PORT) { digitalWrite( LED_BUILTIN, HIGH); BTSerial.print( buffer); digitalWrite( LED_BUILTIN, LOW);}
}
void SerialPrint( char buffer, int nPort) {
	if( nPort & USB_PORT) Serial.print( buffer);
	if( nPort & BT_PORT) { digitalWrite( LED_BUILTIN, HIGH); BTSerial.print( buffer); digitalWrite( LED_BUILTIN, LOW);}
}
void SerialPrint( const char* buffer, int nPort) {
	if( nPort & USB_PORT) Serial.print( buffer);
	if( nPort & BT_PORT) { digitalWrite( LED_BUILTIN, HIGH); BTSerial.print( buffer); digitalWrite( LED_BUILTIN, LOW);}
}
void SerialPrint( int buffer, int nPort) {
	if( nPort & USB_PORT) Serial.print( buffer);
	if( nPort & BT_PORT) { digitalWrite( LED_BUILTIN, HIGH); BTSerial.print( buffer); digitalWrite( LED_BUILTIN, LOW);}
}
void SerialPrint( unsigned int buffer, int nPort) {
	if( nPort & USB_PORT) Serial.print( buffer);
	if( nPort & BT_PORT) { digitalWrite( LED_BUILTIN, HIGH); BTSerial.print( buffer); digitalWrite( LED_BUILTIN, LOW);}
}
void SerialPrint( unsigned long buffer, int nPort) {
	if( nPort & USB_PORT) Serial.print( buffer);
	if( nPort & BT_PORT) { digitalWrite( LED_BUILTIN, HIGH); BTSerial.print( buffer); digitalWrite( LED_BUILTIN, LOW);}
}

// SerialPrintln() + overloads
void SerialPrintln( const __FlashStringHelper* buffer, int nPort) {
	if( nPort & USB_PORT) Serial.println( buffer);
	if( nPort & BT_PORT) { digitalWrite( LED_BUILTIN, HIGH); BTSerial.println( buffer); digitalWrite( LED_BUILTIN, LOW);}
}
void SerialPrintln( const char* buffer, int nPort) {
	if( nPort & USB_PORT) Serial.println( buffer);
	if( nPort & BT_PORT) { digitalWrite( LED_BUILTIN, HIGH); BTSerial.println( buffer); digitalWrite( LED_BUILTIN, LOW);}
}
void SerialPrintln( int buffer, int nPort) {
	if( nPort & USB_PORT) Serial.println( buffer);
	if( nPort & BT_PORT) { digitalWrite( LED_BUILTIN, HIGH); BTSerial.println( buffer); digitalWrite( LED_BUILTIN, LOW);}
}
void SerialPrintln( int nPort) {
	if( nPort & USB_PORT) Serial.println();
	if( nPort & BT_PORT) { digitalWrite( LED_BUILTIN, HIGH); BTSerial.println(); digitalWrite( LED_BUILTIN, LOW);}
}
